<!DOCTYPE html>
<html lang="en" data-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTA SA FXP Editor</title>

    <link rel="stylesheet" href="css/Theme.css"> <!-- Daisy UI -->
    <link rel="stylesheet" href="css/all.min.css"><!-- Font awesome -->
    <script src="js/Tailwind.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        gray: { 750: '#2d3748', 850: '#1a202c', 950: '#171923' }
                    }
                }
            }
        }
    </script>
    <style>
        [data-theme="dark"] {
            /* Change Primary (Pink) to Blue (#3b82f6) */
            --p: 217 91% 60%;
            /* HSL values for Blue */
            --pf: 217 91% 50%;
            /* Darker blue for focus/hover */
            --pc: 0 0% 100%;
            /* White text on primary buttons */

            /* Change Secondary (Purple) to a darker Blue or Accent */
            --s: 220 14% 96%;
            --sf: 220 14% 86%;
            --sc: 220 14% 10%;

            /* Adjust Range Slider colors if needed */
            --in: 198 93% 60%;
            /* Info color */
            --su: 158 64% 52%;
            /* Success color */
            --wa: 43 96% 56%;
            /* Warning color */
            --er: 0 91% 71%;
            /* Error color */
        }

        /* Force Override for specific button states if CSS variables fail */
        .btn-primary {
            background-color: #3b82f6 !important;
            border-color: #3b82f6 !important;
            color: white !important;
        }

        .btn-primary:hover {
            background-color: #2563eb !important;
            border-color: #2563eb !important;
        }

        /* Fix Range Sliders to use Blue instead of Pink */
        .range-primary {
            --range-shdw: #3b82f6;
        }

        /* Fix Toggles to use Blue */
        .toggle-primary:checked,
        .toggle-primary[checked="true"],
        .toggle-primary[aria-checked="true"] {
            --tglbg: #3b82f6;
            background-color: #3b82f6 !important;
        }
    </style>
    <style>
        .custom-scroll::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .custom-scroll::-webkit-scrollbar-track {
            background: #1f2937;
        }

        .custom-scroll::-webkit-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }

        .custom-scroll::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }

        .tree-item {
            cursor: pointer;
            user-select: none;
            padding: 4px 8px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background 0.2s;
            margin-bottom: 2px;
            border: 1px solid transparent;
        }

        .tree-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .tree-item.selected {
            background-color: #2563eb;
            color: white;
            border-color: #3b82f6;
        }

        .tree-children {
            margin-left: 14px;
            border-left: 1px solid #374151;
            padding-left: 4px;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            overflow: hidden;
            /* Initially tall to allow transitions */
            max-height: 5000px;
            opacity: 1;
        }

        /* New class for collapse/expand */
        .tree-children.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .delete-btn {
            opacity: 0.2;
            transition: all 0.2s;
            background: none;
            border: none;
            color: #f87171;
            padding: 2px 6px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .tree-item.selected .delete-btn {
            opacity: 1;
        }

        .delete-btn:hover {
            background-color: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            transform: scale(1.1);
            opacity: 1;
        }

        .add-btn {
            opacity: 0.2;
            /* Always visible if rendered */
            transition: all 0.2s;
            background: none;
            border: none;
            color: #4ade80;
            /* Green-400 */
            padding: 2px 6px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 4px;
            /* Spacing next to trash icon */
            z-index: 10;
        }

        .add-btn:hover {
            opacity: 1;
        }

        .copy-btn {
            background: none;
            border: none;
            color: #60a5fa;
            /* Blue-400 */
            padding: 2px 6px;
            margin-right: 2px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.2;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background-color: rgba(96, 165, 250, 0.2);
            opacity: 1;
            transform: scale(1.1);
        }

        .paste-btn {
            background: none;
            border: none;
            color: #fbbf24;
            /* Amber-400 */
            padding: 2px 6px;
            margin-right: 2px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.1;
            transition: all 0.2s;
        }

        .paste-btn:hover {
            background-color: rgba(251, 191, 36, 0.2);
            opacity: 1;
            transform: scale(1.1);
        }

        .add-btn:hover {
            background-color: rgba(74, 222, 128, 0.2);
            color: #22c55e;
            transform: scale(1.1);
        }

        #render-canvas {
            width: 100%;
            height: 100%;
            display: block;
            outline: none;
        }

        .selected-tile {
            /* Modified selection style for multi-select */
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            background-color: #3b82f6 !important;
            /* Blue 500 equivalent */
            color: white !important;
            border-color: #2563eb !important;
        }

        #fx_type_tile_container .card-body {
            min-height: 6rem;
            /* Ensures the tile body is visible */
        }

        .texture-tile {
            aspect-ratio: 1;
            background-color: #1f2937;
            /* Gray-800 */
            border: 2px solid transparent;
            border-radius: 0.5rem;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .texture-tile:hover {
            border-color: #3b82f6;
            /* Primary Blue */
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .texture-tile img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            padding: 4px;
        }

        .texture-tile span {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 0.65rem;
            text-align: center;
            padding: 2px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    </style>
</head>

<body class="h-screen w-screen flex flex-col overflow-hidden bg-base-100 text-base-content font-sans">

    <div
        class="navbar bg-base-300 min-h-[3rem] h-12 px-4 border-b border-base-content/10 shadow-md z-50 flex justify-between">
        <div class="flex items-center gap-2">


            <button class="btn btn-sm btn-circle btn-ghost text-info"
                onclick="document.getElementById('help_modal').showModal()" title="Help / First Steps">
                <i class="fas fa-question text-lg"></i>
            </button>
            <div class="divider divider-horizontal mx-1"></div>
            <div class="dropdown dropdown-hover">
                <label tabindex="0" class="btn btn-sm btn-ghost"><i class="fas fa-file mr-1"></i> File</label>
                <ul tabindex="0" class="dropdown-content z-50 menu p-2 shadow bg-base-200 rounded-box w-52">
                    <li><a onclick="app.newProject()"><i class="fas fa-file-circle-plus"></i> New Project</a></li>
                    <li><label for="file-upload"><i class="fas fa-folder-open"></i> Open FXP</label></li>
                    <li><a onclick="saveToFile()"><i class="fas fa-save"></i> Save FXP</a></li>
                    <li><a onclick="copyToClipboard()"><i class="fas fa-copy"></i> Copy to Clipboard</a></li>
                </ul>
            </div>
            <input type="file" id="file-upload" class="hidden" accept=".fxp,.txt,.fxs"
                onchange="handleFileUpload(this)">

            <label class="btn btn-sm btn-ghost" for="texture-upload" title="Load .png textures referenced in the FXP">
                <i class="fas fa-images"></i> Load Textures
            </label>
            <input type="file" id="texture-upload" class="hidden" webkitdirectory directory multiple
                onchange="handleTextureUpload(this)">

            <div class="divider divider-horizontal mx-1"></div>

            <div class="form-control ml-4">
                <label class="label cursor-pointer gap-2">
                    <span class="label-text text-xs font-bold">Autosave</span>
                    <input type="checkbox" class="toggle toggle-xs toggle-success" id="autosave-toggle"
                        onchange="toggleAutosave(this)" checked />
                </label>
            </div>

            <div class="divider divider-horizontal mx-1"></div>
            <span class="font-bold text-lg text-primary"><i class="fas fa-fire-smoke mr-2"></i>GTA SA FXP Editor</span>
        </div>

        <div class="flex items-center gap-2">
            <div class="join">
                <button class="btn btn-sm join-item btn-neutral" onclick="app.sim.reset()" title="Reset Simulation"><i
                        class="fas fa-stop"></i></button>
                <button class="btn btn-sm join-item btn-primary" onclick="app.sim.togglePlay()" id="play-btn"
                    title="Play/Pause"><i class="fas fa-play"></i></button>
            </div>

            <!-- Repeat Toggle Button -->
            <button class="btn btn-sm btn-primary" onclick="app.sim.toggleRepeat()" id="repeat-toggle"
                title="Toggle System Looping (Repeat)">
                <i class="fas fa-redo"></i> Repeat
            </button>

            <!-- G-Force Toggle Button -->
            <button class="btn btn-sm btn-neutral" onclick="app.sim.toggleGForce()" id="gforce-btn"
                title="Toggle Gravity (G-Force)">
                G
            </button>

            <button class="btn btn-sm btn-primary" id="grid-toggle-btn" onclick="app.sim.toggleGrid()"
                title="Show/Hide Grid">
                <i class="fas fa-border-all"></i>
            </button>

            <div class="dropdown dropdown-hover dropdown-end">
                <label tabindex="0" class="btn btn-sm btn-neutral" id="ground-btn" title="Adjust Ground Height">
                    <i class="fas fa-layer-group"></i> <span id="ground-val">-1.0</span>
                </label>
                <ul tabindex="0"
                    class="dropdown-content z-[1] menu p-4 shadow bg-base-200 rounded-box w-64 border border-base-content/10">
                    <li>
                        <div class="form-control">
                            <label class="label cursor-pointer">
                                <span class="label-text font-bold text-xs">Ground Height (Y)</span>
                            </label>
                            <input type="range" min="-5" max="0" step="0.1" value="-1.0"
                                class="range range-xs range-accent" oninput="app.updateGroundHeight(this.value)" />
                            <div class="w-full flex justify-between text-xs px-2 mt-2 opacity-50">
                                <span>-5</span>
                                <span>-1</span>
                                <span>+2</span>
                            </div>
                        </div>
                    </li>
                </ul>
            </div>

            <div class="dropdown dropdown-hover dropdown-end">
                <label tabindex="0" class="btn btn-sm btn-neutral" id="wind-btn" title="Adjust Global Wind">
                    <i class="fas fa-wind"></i> <span id="wind-val">OFF</span>
                </label>
                <ul tabindex="0"
                    class="dropdown-content z-[1] menu p-4 shadow bg-base-200 rounded-box w-64 border border-base-content/10">
                    <li>
                        <div class="form-control">
                            <label class="label cursor-pointer py-0">
                                <span class="label-text font-bold text-xs">Wind X</span>
                                <span class="text-xs opacity-50" id="wind-x-val">0.0</span>
                            </label>
                            <input type="range" min="-10" max="10" step="0.5" value="0"
                                class="range range-xs range-info" oninput="app.updateWind('x', this.value)" />
                        </div>
                    </li>
                    <li class="mt-2">
                        <div class="form-control">
                            <label class="label cursor-pointer py-0">
                                <span class="label-text font-bold text-xs">Wind Z</span>
                                <span class="text-xs opacity-50" id="wind-z-val">0.0</span>
                            </label>
                            <input type="range" min="-10" max="10" step="0.5" value="0"
                                class="range range-xs range-info" oninput="app.updateWind('z', this.value)" />
                        </div>
                    </li>
                    <li class="mt-2 text-xs text-center opacity-50">
                        (Requires FX_INFO_WIND_DATA)
                    </li>
                </ul>
            </div>

            <!-- Background Switcher Button -->
            <button class="btn btn-sm btn-ghost" onclick="app.sim.changeBackground()" title="Change Background Color">
                <i class="fas fa-fill-drip"></i> BG
            </button>

            <span class="text-xs">Speed:</span>
            <input type="range" min="0.1" max="1.0" step="0.1" value="1.0" class="range range-xs range-primary w-24"
                oninput="app.sim.timeScale = parseFloat(this.value)">


            <label class="swap swap-rotate btn btn-sm btn-circle btn-ghost">
                <input type="checkbox" id="theme-toggle" />
                <i class="swap-on fas fa-sun text-yellow-400"></i>
                <i class="swap-off fas fa-moon text-blue-300"></i>
            </label>
        </div>
    </div>

    <div class="flex flex-1 overflow-hidden">

        <div class="w-96 flex flex-col bg-base-200 border-r border-base-content/10">
            <div class="p-2 bg-base-300 font-bold text-xs uppercase tracking-wider flex justify-between items-center">
                Hierarchy
                <button class="btn btn-sm btn-success btn-outline" onclick="app.addSystem()"><i class="fas fa-plus"></i>
                    New
                    System</button>
            </div>
            <div id="tree-root" class="flex-1 overflow-y-auto custom-scroll p-2 text-sm select-none">
            </div>
        </div>

        <div class="flex-1 flex flex-col h-full relative">

            <div class="flex-1 bg-gray-900 relative group overflow-hidden" id="viewport-container">
                <div
                    class="absolute bottom-0 left-1/2 -translate-x-1/2 w-[30%]  text-red-100 opacity-50 text-center text-xs py-1 font-bold pointer-events-none z-20  backdrop-blur-sm shadow-lg">
                    <i class="fas fa-exclamation-triangle mr-2"></i>
                    Rendering may differ from in-game. verify results in GTA.
                </div>

                <canvas id="render-canvas"></canvas>
                <div class="absolute top-2 left-2 text-white/50 text-xs pointer-events-none bg-black/30 p-1 rounded z-10"
                    id="sim-status">
                    No System Selected
                </div>
                <div class="absolute top-2 right-2 bg-black/50 text-white text-xs p-2 rounded pointer-events-none z-10">
                    <div id="debug-info">Particles: 0</div>
                    <div>LMB: Orbit | RMB: Pan | Wheel: Zoom</div>
                </div>
                <div
                    class="absolute bottom-2 right-2 text-right pointer-events-none z-10 opacity-50 text-[10px] text-gray-400 select-none flex flex-col gap-0.5">
                    <span class="font-bold uppercase text-gray-500 mb-1">Editor Limitations</span>
                    <span><i class="fas fa-eye-slash mr-1"></i> FLAT & DIR data not visualized</span>
                    <span><i class="fas fa-bug mr-1"></i> TRAIL rendering is experimental</span>
                </div>
            </div>

            <div class="h-1/3 bg-base-100 border-t border-base-content/10 flex flex-col shadow-inner z-20">
                <div
                    class="p-2 bg-base-300 font-bold text-xs uppercase tracking-wider flex justify-between items-center">
                    <span id="prop-title">Properties</span>
                    <div id="prop-actions" class="flex gap-2">
                    </div>
                </div>
                <div id="property-editor" class="flex-1 overflow-y-auto custom-scroll p-4">
                    <div class="text-base-content/30 italic text-center mt-10">
                        Select an item in the tree to edit properties.
                    </div>
                </div>
            </div>

        </div>
    </div>

    <dialog id="add_fx_modal" class="modal">
        <div class="modal-box w-11/12 max-w-6xl max-h-screen">
            <h3 class="font-bold text-xl mb-4">Add FX Info Block</h3>
            <p class="py-2 text-sm opacity-70">Select the type of data block to add to this Emitter (Multi-select
                enabled):</p>
            <div id="fx_type_tile_container"
                class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3 max-h-[80vh] overflow-y-auto custom-scroll p-2">
                <!-- Tiles generated by JS will go here -->
            </div>
            <div class="modal-action">
                <form method="dialog">
                    <button class="btn btn-ghost">Cancel</button>
                    <button id="confirm_add_fx_btn" class="btn btn-primary" onclick="app.confirmAddFx()" disabled>Add
                        Selected Blocks</button>
                </form>
            </div>
        </div>
    </dialog>

    <!-- NEW: Custom Confirmation Modal -->
    <dialog id="custom_confirm_modal" class="modal">
        <div class="modal-box">
            <h3 class="font-bold text-lg" id="confirm_title">Confirm Action</h3>
            <p class="py-4" id="confirm_message">Are you sure you want to proceed?</p>
            <div class="modal-action">
                <button class="btn btn-error" id="confirm_cancel_btn">Cancel</button>
                <button class="btn btn-success" id="confirm_ok_btn">OK</button>
            </div>
        </div>
    </dialog>


    <div id="toast-container" class="toast toast-top toast-end z-50"></div>


    <dialog id="help_modal" class="modal">
        <div class="modal-box w-11/12 max-w-4xl">
            <div class="flex justify-between items-center mb-4 border-b border-base-content/10 pb-2">
                <h3 class="font-bold text-2xl text-primary"><i class="fas fa-graduation-cap mr-2"></i> First Steps Guide
                </h3>
                <form method="dialog">
                    <button class="btn btn-sm btn-circle btn-ghost">âœ•</button>
                </form>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 text-sm">

                <div class="space-y-4">
                    <div class="card bg-base-200 shadow-sm border border-base-content/5">
                        <div class="card-body p-4">
                            <h4 class="card-title text-base text-accent"><i class="fas fa-folder-open"></i> 1. Loading &
                                Saving</h4>
                            <ul class="list-disc list-inside opacity-80 space-y-1">
                                <li><strong>Open FXP:</strong> Load an existing GTA <code>.fxp</code> file.</li>
                                <li><strong>Load Textures:</strong> Click "Load Textures" and select a
                                    <strong>folder</strong> containing your .png images. The editor will match them by
                                    name.
                                </li>
                                <li><strong>Clipboard:</strong> Use "Copy to Clipboard" to quickly paste data into a
                                    text editor.</li>
                            </ul>
                        </div>
                    </div>

                    <div class="card bg-base-200 shadow-sm border border-base-content/5">
                        <div class="card-body p-4">
                            <h4 class="card-title text-base text-accent"><i class="fas fa-sitemap"></i> 2. The Hierarchy
                            </h4>
                            <ul class="list-disc list-inside opacity-80 space-y-1">
                                <li><strong>System:</strong> The root container (e.g., "Explosion").</li>
                                <li><strong>Emitter:</strong> The actual source of particles (e.g., "Debris", "Smoke").
                                </li>
                                <li><strong>FX Info:</strong> Data blocks defining behavior (Speed, Color, Life).</li>
                                <li><span class="text-success font-bold">+</span> <strong>Button:</strong> Hover over a
                                    selected item in the tree to add new Emitters or Info blocks.</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="space-y-4">
                    <div class="card bg-base-200 shadow-sm border border-base-content/5">
                        <div class="card-body p-4">
                            <h4 class="card-title text-base text-accent"><i class="fas fa-sliders-h"></i> 3. Editing
                                Properties</h4>
                            <ul class="list-disc list-inside opacity-80 space-y-1">
                                <li>Select an item in the tree to see its properties below the viewport.</li>
                                <li><strong>Timelines:</strong> Many properties (Color, Size) change over time. Click
                                    <strong>+</strong> to add keyframes.
                                </li>
                                <li><strong>Blend Modes:</strong> Use the dropdowns on the Emitter to change blending
                                    (e.g., "Additive" for fire, "Alpha" for smoke).</li>
                            </ul>
                        </div>
                    </div>

                    <div class="card bg-base-200 shadow-sm border border-base-content/5">
                        <div class="card-body p-4">
                            <h4 class="card-title text-base text-accent"><i class="fas fa-camera"></i> 4. Viewport
                                Controls</h4>
                            <div class="grid grid-cols-2 gap-2 mt-2">
                                <div class="badge badge-neutral w-full">LMB + Drag</div> <span class="opacity-70">Orbit
                                    Camera</span>
                                <div class="badge badge-neutral w-full">RMB + Drag</div> <span class="opacity-70">Pan
                                    Camera</span>
                                <div class="badge badge-neutral w-full">Scroll</div> <span
                                    class="opacity-70">Zoom</span>
                            </div>
                        </div>
                    </div>
                </div>

            </div>

            <div class="mt-6 pt-4 border-t border-base-content/10 text-xs opacity-50 text-center">
                <i class="fas fa-exclamation-triangle text-warning"></i> Warning: WebGL rendering is an approximation.
                Always verify final visuals in-game.
            </div>

            <div class="modal-action">
                <form method="dialog">
                    <button class="btn btn-primary">Got it!</button>
                </form>
            </div>
        </div>
    </dialog>

    <dialog id="texture_browser_modal" class="modal">
        <div class="modal-box w-11/12 max-w-5xl">
            <h3 class="font-bold text-lg mb-4">Select Loaded Texture</h3>

            <div id="texture_browser_grid"
                class="grid grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-4 max-h-[60vh] overflow-y-auto custom-scroll p-2">
            </div>

            <div class="modal-action">
                <form method="dialog">
                    <button class="btn btn-ghost">Cancel</button>
                </form>
            </div>
        </div>
    </dialog>


    <script>
        // --- HELPERS ---
        function uuid() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }

        // --- CONSTANTS ---
        const FPS_STEP = 1 / 60; // 30 frames per second target simulation rate


        const FX_DEFAULTS = {
            system: function () {
                return {
                    _id: uuid(),
                    name: 'UnnamedSystem',
                    length: undefined,
                    loopInterval: 0,
                    playMode: 0,
                    culldistance: 50.000,
                    boundingsphere: [0.0, 0.0, 0.0, 0.0],
                    omittextures: 0,
                    txdname: 'NOTXDSET',
                    emitters: []
                };
            },
            emitter: function () {
                return {
                    _id: uuid(),
                    name: 'Emitter',
                    matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
                    alphaOn: 1,
                    lodstart: 30.0,
                    lodend: 50.0,
                    texture: 'null',
                    texture2: 'null',
                    texture3: 'null',
                    texture4: 'null',
                    infos: []
                };
            }
        };

        const FX_INFO_TYPES_MAP = [
            { type: "FX_INFO_EMRATE_DATA", name: "Emission Rate", desc: "Controls the particle emission rate over the system's lifetime.", icon: "fa-tachometer-alt" },
            { type: "FX_INFO_EMSPEED_DATA", name: "Initial Speed", desc: "Sets the particle's initial speed and random velocity bias.", icon: "fa-bolt" },
            { type: "FX_INFO_EMLIFE_DATA", name: "Particle Life", desc: "Defines the lifespan of emitted particles.", icon: "fa-clock" },
            { type: "FX_INFO_EMPOS_DATA", name: "Emitter Position", desc: "Sets the constant offset for the emitter's spawn position.", icon: "fa-crosshairs" },
            { type: "FX_INFO_EMSIZE_DATA", name: "Emission Volume", desc: "Defines the volume (radius/box) where particles spawn, relative to the emitter.", icon: "fa-cube" },
            { type: "FX_INFO_EMDIR_DATA", name: "Emission Direction", desc: "Sets the primary direction vector for particle movement.", icon: "fa-location-arrow" },
            { type: "FX_INFO_EMANGLE_DATA", name: "Emission Angle", desc: "Defines the cone angle/spread of the initial particle velocity direction.", icon: "fa-compress-alt" },
            { type: "FX_INFO_EMROTATION_DATA", name: "Initial Rotation", desc: "Sets the initial rotation angle for the particle sprite.", icon: "fa-redo" },
            { type: "FX_INFO_FORCE_DATA", name: "External Force", desc: "Defines constant or time-varying forces (e.g., wind, magnetism) acting on particles.", icon: "fa-weight-hanging" },
            { type: "FX_INFO_SIZE_DATA", name: "Particle Size", desc: "Controls the visual size (X and Y dimensions) of the particle sprite over its life.", icon: "fa-expand-alt" },
            { type: "FX_INFO_COLOUR_DATA", name: "Particle Color", desc: "Controls the Red, Green, Blue, and Alpha color channels over the particle's life.", icon: "fa-palette" },
            { type: "FX_INFO_COLOURBRIGHT_DATA", name: "Color & Brightness", desc: "Color data that includes an extra Brightness Bias control.", icon: "fa-lightbulb" },
            { type: "FX_INFO_ROTSPEED_DATA", name: "Rotation Speed", desc: "Sets the constant or time-varying rotational speed of the particle sprite.", icon: "fa-sync-alt" },
            { type: "FX_INFO_FRICTION_DATA", name: "Friction / Drag", desc: "Defines air resistance or drag acting on particle velocity.", icon: "fa-shoe-prints" },
            { type: "FX_INFO_WIND_DATA", name: "Wind Factor", desc: "Controls how much external wind/weather affects the particle's movement.", icon: "fa-wind" },
            { type: "FX_INFO_GROUNDCOLLIDE_DATA", name: "Ground Collision", desc: "Defines behavior when particles hit the ground (bounce, speed reduction).", icon: "fa-mountain" },
            { type: "FX_INFO_TRAIL_DATA", name: "Trail", desc: "Configures properties for rendering a particle trail behind the main particle.", icon: "fa-meteor" },
            { type: "FX_INFO_ATTRACTPT_DATA", name: "Attraction Point", desc: "Defines a point in space that attracts particles with a customizable force.", icon: "fa-magnet" },
            { type: "FX_INFO_SPRITERECT_DATA", name: "Sprite Rect (UV)", desc: "Defines the UV coordinates for sprite sheet animation/selection.", icon: "fa-image" },
            { type: "FX_INFO_ANIMTEX_DATA", name: "Animated Texture", desc: "Controls which  of the textures to display.", icon: "fa-film" },
            { type: "FX_INFO_DIR_DATA", name: "Particle Alignment", desc: "Defines a direction vector for particle alignment or secondary effects.", icon: "fa-vector-square" },
            { type: "FX_INFO_FLAT_DATA", name: "Flat Alignment", desc: "Defines fixed orientation vectors for the particle sprite (making it 'flat').", icon: "fa-grip-lines-vertical" },
            { type: "FX_INFO_JITTER_DATA", name: "Jitter Noise", desc: "Defines parameters for particle jitter/random movement.", icon: "fa-random" },
            { type: "FX_INFO_NOISE_DATA", name: "Noise/Perlin", desc: "Adds smooth random movement to the particle position.", icon: "fa-wave-square" },
            { type: "FX_INFO_HEATHAZE_DATA", name: "Heat Haze", desc: "Configures properties for a heat haze visual effect.", icon: "fa-smog" },
            { type: "FX_INFO_UNDERWATER_DATA", name: "Underwater Flag", desc: "A marker for underwater-specific behavior.", icon: "fa-water" },
            { type: "FX_INFO_SELFLIT_DATA", name: "Self-Lit Flag", desc: "Marks particle as unaffected by lighting.", icon: "fa-star" },
            { type: "FX_INFO_FLOAT_DATA", name: "Generic Float", desc: "A placeholder for generic float data.", icon: "fa-hashtag" },
            { type: "FX_INFO_EMWEATHER_DATA", name: "Weather Link", desc: "Links emitter rate/properties to weather effects (rain, wind).", icon: "fa-cloud-sun-rain" },
        ];

        // Retain the old flat array for compatibility with old code logic (like default info block initialization)
        const FX_INFO_TYPES = FX_INFO_TYPES_MAP.map(function (i) { return i.type; });

        // G-Force proxy value (Vertical acceleration in Three.js Y-up system)
        const G_FORCE_PROXY = -9.8;

        // NEW: Background color definitions
        const BACKGROUND_COLORS = [
            { name: 'Dark Blue/Black', color: 0x111827 }, // Default
            { name: 'White', color: 0xffffff },
            { name: 'Black', color: 0x000000 },
            { name: 'Green (SA Sky)', color: 0x477838 }
        ];

        // --- CUSTOM POPUP IMPLEMENTATION ---

        /**
         * Custom Promise-based confirm dialog replacement.
         * @param {string} message 
         * @param {string} [title="Confirm Action"]
         * @returns {Promise<boolean>}
         */
        function customConfirm(message, title = "Confirm Action") {
            return new Promise(function (resolve) {
                const modal = document.getElementById('custom_confirm_modal');
                if (!modal) {
                    console.error("Custom confirm modal not found. Falling back to true.");
                    return resolve(true);
                }

                document.getElementById('confirm_title').innerText = title;
                document.getElementById('confirm_message').innerText = message;

                const okBtn = document.getElementById('confirm_ok_btn');
                const cancelBtn = document.getElementById('confirm_cancel_btn');

                // Clear previous listeners
                const clearListeners = function () {
                    okBtn.onclick = null;
                    cancelBtn.onclick = null;
                    modal.close();
                };

                okBtn.onclick = function () {
                    clearListeners();
                    resolve(true);
                };

                cancelBtn.onclick = function () {
                    clearListeners();
                    resolve(false);
                };

                modal.showModal();
            });
        }

        /**
         * Custom non-blocking alert dialog replacement (uses toast).
         * This function replaces browser's alert(), which is forbidden.
         * @param {string} message 
         * @param {string} [type="info"] 
         */
        function customAlert(message, type = "info") {
            showToast(message, type);
        }

        // --- 1. PARSER ---
        // Change class FXParser to const FXParser = class to ensure reliable global definition
        const FXParser = class {
            static parse(text) {
                const lines = text.split(/\r?\n/);
                const project = { systems: [] };

                let activeSystem = null;
                let activeEmitter = null;
                let activeInfo = null;
                let context = 'ROOT';

                let i = 0;
                while (i < lines.length) {
                    let line = lines[i].trim();
                    i++;
                    if (!line || line.startsWith('//') || line.startsWith('FX_PROJECT_DATA')) continue;

                    // Headers
                    if (line.includes('FX_SYSTEM_DATA:')) {
                        // Note: Initialize length to undefined so we know if it has been parsed yet.
                        activeSystem = FX_DEFAULTS.system();
                        project.systems.push(activeSystem);
                        activeEmitter = null; activeInfo = null;
                        context = 'SYSTEM';
                        continue;
                    }

                    if (line.includes('FX_PRIM_BASE_DATA:')) {
                        if (activeSystem) {
                            activeEmitter = FX_DEFAULTS.emitter();
                            activeSystem.emitters.push(activeEmitter);
                            activeInfo = null;
                            context = 'EMITTER';
                        }
                        continue;
                    }

                    // Info Header Detection
                    let isInfoHeader = false;
                    for (let type of FX_INFO_TYPES) {
                        if (line.includes(type)) {
                            if (activeEmitter) {
                                activeInfo = { _id: uuid(), type: type.replace(':', ''), data: {} };
                                activeEmitter.infos.push(activeInfo);
                                context = 'INFO';
                                isInfoHeader = true;
                            }
                            break;
                        }
                    }
                    if (isInfoHeader) continue;

                    // Properties
                    if (line.includes(':')) {
                        const splitIdx = line.indexOf(':');
                        const key = line.substring(0, splitIdx).trim();
                        const valStr = line.substring(splitIdx + 1).trim();

                        // NAME Handling: Assign based on current context
                        if (key === 'NAME') {
                            if (context === 'EMITTER' && activeEmitter) activeEmitter.name = valStr;
                            else if (context === 'SYSTEM' && activeSystem) activeSystem.name = valStr;
                            continue;
                        }


                        if (key == 'OMITTEXTURES' || key == 'TXDNAME' || key == 'LODSTART' || key == 'LODEND') {
                            if (key === 'TXDNAME') activeSystem.txdname = valStr;
                            else if (key === 'OMITTEXTURES') activeSystem.omittextures = parseInt(valStr);
                            else if (key === 'LODSTART') activeEmitter.lodstart = parseFloat(valStr);
                            else if (key === 'LODEND') activeEmitter.lodend = parseFloat(valStr);
                            continue;
                        }
                        if (context === 'INFO' && activeInfo) {
                            if (valStr === '') {
                                const interp = FXParser.parseInterpolation(lines, i);
                                if (interp.data) {
                                    activeInfo.data[key] = interp.data;
                                    i = interp.newIndex;
                                }
                            } else {
                                if (key === 'TIMEMODEPRT') {
                                    activeInfo.data[key] = parseInt(valStr, 10);
                                } else {
                                    const num = parseFloat(valStr);
                                    activeInfo.data[key] = isNaN(num) ? valStr : num;
                                }
                            }
                        }
                        else if (context === 'EMITTER' && activeEmitter) {
                            if (key === 'TEXTURE') activeEmitter.texture = valStr;
                            else if (key === 'TEXTURE2') activeEmitter.texture2 = valStr;
                            else if (key === 'TEXTURE3') activeEmitter.texture3 = valStr;
                            else if (key === 'TEXTURE4') activeEmitter.texture4 = valStr;
                            else if (key === 'MATRIX') activeEmitter.matrix = valStr.split(' ').map(parseFloat);
                            else if (key === 'SRCBLENDID') activeEmitter.srcBlend = parseInt(valStr);
                            else if (key === 'DSTBLENDID') activeEmitter.dstBlend = parseInt(valStr);

                        }
                        else if (context === 'SYSTEM' && activeSystem) {
                            // FIX: Only set LENGTH if it is currently undefined (i.e., this is the first LENGTH property found)
                            if (key === 'LENGTH') {
                                if (activeSystem.length === undefined) {
                                    activeSystem.length = parseFloat(valStr);
                                }
                            }
                            else if (key === 'LOOPINTERVALMIN') activeSystem.loopInterval = parseFloat(valStr);
                            else if (key === 'PLAYMODE') activeSystem.playMode = parseInt(valStr);
                            else if (key === 'CULLDIST') activeSystem.culldistance = parseFloat(valStr);
                            else if (key === 'BOUNDINGSPHERE') activeSystem.boundingsphere = valStr.split(' ').map(parseFloat);

                        }
                    }
                }
                // Final sanity check: If LENGTH was never set, default it to 1.0
                project.systems.forEach(function (sys) {
                    if (sys.length === undefined) sys.length = 1.0;
                });

                return project;
            }

            static parseInterpolation(lines, startIndex) {
                let keys = [];
                let i = startIndex;
                let looped = 0;
                let found = false;

                let scanIdx = i;
                while (scanIdx < lines.length && scanIdx < i + 5) {
                    if (lines[scanIdx].includes('FX_INTERP_DATA:')) { found = true; break; }
                    if (lines[scanIdx].includes(':') && !lines[scanIdx].includes('FX_INTERP_DATA')) break;
                    scanIdx++;
                }
                if (!found) return { data: null, newIndex: startIndex };

                i = scanIdx + 1; // Consume Header

                while (i < lines.length) {
                    let line = lines[i].trim();
                    if (line.includes('LOOPED:')) looped = parseInt(line.split(':')[1]);
                    else if (line.includes('FX_KEYFLOAT_DATA:')) {
                        let timeLine = lines[++i].trim();
                        let valLine = lines[++i].trim();
                        keys.push({
                            time: parseFloat(timeLine.split(':')[1]),
                            val: parseFloat(valLine.split(':')[1])
                        });
                    } else if (line.includes(':') && !line.startsWith('TIME') && !line.startsWith('VAL') && !line.startsWith('NUM_KEYS')) {
                        break;
                    } else if (line === '' || line.startsWith('FX_')) {
                        break;
                    }
                    i++;
                }
                return { data: { looped, keys }, newIndex: i };
            }

            static stringify(project) {
                let out = "FX_PROJECT_DATA:\n\n";
                project.systems.forEach(function (sys) {
                    out += FXParser.stringifySystem(sys);
                });
                out += "FX_PROJECT_DATA_END:\n";
                return out;
            }

            static stringifySystem(sys) {
                let out = "FX_SYSTEM_DATA:\n109\n\n";
                out += `FILENAME: X:\\SA\\FxTools\\Data\\effects\\gta_pc\\particles/${sys.name}.fxs\n`;
                out += `NAME: ${sys.name}\n`;
                out += `LENGTH: ${(sys.length || 1.0).toFixed(3)}\n`;
                out += `LOOPINTERVALMIN: ${(sys.loopInterval || 0).toFixed(3)}\n`;
                out += `LENGTH: 0.000\n`;
                out += `PLAYMODE: ${sys.playMode !== undefined ? sys.playMode : 2}\n`;
                out += `CULLDIST: ${(sys.culldistance || 100).toFixed(3)}\n`;
                out += `BOUNDINGSPHERE: ${(sys.boundingsphere || [0, 0, 0, 0]).map(function (n) { return n.toFixed(3); }).join(' ')}\n`;
                out += `NUM_PRIMS: ${sys.emitters.length}\n`;

                sys.emitters.forEach(function (em) {
                    out += "FX_PRIM_EMITTER_DATA:\n\n";
                    out += "FX_PRIM_BASE_DATA:\n";
                    out += `NAME: ${em.name}\n`;
                    out += `MATRIX: ${(em.matrix || [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0]).map(function (n) { return n.toFixed(3); }).join(' ')} \n`;
                    out += `TEXTURE: ${em.texture || 'null'}\n`;
                    out += `TEXTURE2: ${em.texture2 || 'null'}\n`;
                    out += `TEXTURE3: ${em.texture3 || 'null'}\n`;
                    out += `TEXTURE4: ${em.texture4 || 'null'}\n`;
                    out += `ALPHAON: ${em.alphaOn !== undefined ? em.alphaOn : 1}\n`;
                    out += `SRCBLENDID: ${em.srcBlend || 4}\n`;
                    out += `DSTBLENDID: ${em.dstBlend || 5}\n\n`;

                    out += `NUM_INFOS: ${em.infos.length}\n`;
                    em.infos.forEach(function (info) {
                        out += `${info.type}:\n`;
                        for (const key in info.data) {
                            if (info.data.hasOwnProperty(key)) {
                                const val = info.data[key];
                                if (val && typeof val === 'object' && val.keys) {
                                    out += `${key}:\nFX_INTERP_DATA:\n`;
                                    out += `LOOPED: ${val.looped || 0}\n`;
                                    out += `NUM_KEYS: ${val.keys.length}\n`;
                                    val.keys.forEach(function (k) {
                                        out += "FX_KEYFLOAT_DATA:\n";
                                        out += `TIME: ${k.time.toFixed(3)}\n`;
                                        out += `VAL: ${k.val.toFixed(3)}\n`;
                                    });
                                } else {
                                    if (key === 'TIMEMODEPRT') {
                                        out += `${key}: ${Math.round(val)}\n`;
                                    } else {
                                        out += `${key}: ${typeof val === 'number' ? val.toFixed(3) : val}\n`;
                                    }
                                }
                            }
                        }
                        out += `\n`;
                    });
                    out += `LODSTART: ${(em.lodstart.toFixed(3) || 20.000)}\n`;
                    out += `LODEND: ${em.lodend.toFixed(3) || 80.000}\n`;
                });
                out += `OMITTEXTURES: ${sys.omittextures || 0}\n`;
                out += `TXDNAME: ${sys.txdname || 'NOTXDSET'}\n`;
                out += `\n`;
                return out;
            }
        };

        // Bind statics
        FXParser.parse = FXParser.parse;
        FXParser.parseInterpolation = FXParser.parseInterpolation;
        FXParser.stringify = FXParser.stringify;
        FXParser.stringifySystem = FXParser.stringifySystem;


        // --- 2. SIMULATION ENGINE ---

        class Particle {
            constructor() {
                this.active = false;
                this.position = new THREE.Vector3();
                this.velocity = new THREE.Vector3();
                this.color = new THREE.Color(1, 1, 1);
                this.alpha = 1.0;
                this.size = 1.0;
                this.life = 1.0;
                this.age = 0.0;
                this.emitterDef = null;
                this.textureName = 'null'; // Stores the texture name for grouping
                this.rotation = 0.0;
                this.rotSpeed = 0.0;
                this.sizeX = 1.0; // Individual X size (horizontal on screen)
                this.sizeY = 1.0; // Individual Y size (vertical on screen)
                this.dirVelocity = new THREE.Vector3(); // NEW: Store normalized velocity for alignment
                this.history = []; // Stores historical positions for trails
                this.trailTimer = 0.0; // <--- ADD THIS for 25fps throttling
                this.rotRandomFactor = 0.0;
                this.rotDirection = 1.0;
            }
        }

        class Simulator {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.particlePool = []; // Renamed from this.particles - the reusable pool
                this.maxParticles = 50000;

                // Fixed Time Step properties
                this.timeAccumulator = 0.0;

                // Point Sprite Meshes
                this.baseShaderMaterial = null; // Template material
                this.textureMeshes = {}; // {textureName: {mesh, geometry, material, particles}}

                // Trail Ribbon Mesh (NEW)
                this.baseTrailMaterial = null; // Trail Material Template
                this.trailMeshes = {}; // {textureName: {mesh, geometry, material, particles}}
                this.maxTrailSegments = 5; // Max number of segments per trail

                this.activeSystem = null;
                this.emittersState = [];
                this.textures = {};
                this.defaultTexture = null;
                this.isPlaying = true;
                this.timeScale = 1.0;
                this.clock = new THREE.Clock();
                this.poolIndex = 0;
                this.isReady = false;
                this.controls = null;

                // NEW: Scene Controls
                this.isGForceEnabled = false;
                this.backgroundIndex = 0;
                this.lastRenderTime = 0;

                // NEW: Repeat Toggle
                this.isRepeatEnabled = true;

                // --- NEW: Environment Controls ---
                this.groundHeight = -1.0;
                this.gridHelper = null;
                this.isGridVisible = true;

                this.globalWind = new THREE.Vector3(0, 0, 0);

                // Bind methods to instance for reliable access in callbacks/setTimeout
                this.init = this.init.bind(this);
                this.animate = this.animate.bind(this);
            }

            // New helper to create geometry attributes structure for POINTS
            createParticleGeometry(maxCount) {
                const pos = new Float32Array(maxCount * 3);
                const col = new Float32Array(maxCount * 3);
                const sz = new Float32Array(maxCount);
                const alp = new Float32Array(maxCount);
                this.rot = new Float32Array(maxCount); // Rotation attribute
                const scale = new Float32Array(maxCount * 2); // vec2 scale attribute
                const dirV = new Float32Array(maxCount * 3); // NEW: vec3 direction velocity attribute
                const spriteRect = new Float32Array(maxCount * 4);
                const texIndex = new Float32Array(maxCount);

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geometry.setAttribute('customColor', new THREE.BufferAttribute(col, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sz, 1));
                geometry.setAttribute('alpha', new THREE.BufferAttribute(alp, 1));
                geometry.setAttribute('rotation', new THREE.BufferAttribute(this.rot, 1));
                geometry.setAttribute('scale', new THREE.BufferAttribute(scale, 2));
                geometry.setAttribute('dirVelocity', new THREE.BufferAttribute(dirV, 3)); // NEW
                geometry.setDrawRange(0, 0); // Initialize draw range
                geometry.setAttribute('spriteRect', new THREE.BufferAttribute(spriteRect, 4));
                geometry.setAttribute('texIndex', new THREE.BufferAttribute(texIndex, 1))
                return geometry;
            }

            // NEW: Helper to create geometry attributes for RIBBONS
            createTrailGeometry(maxParticles, maxSegments) {
                // Max segments + 1 point for a clean end cap
                const maxPointsPerTrail = maxSegments + 1;
                const totalVertices = maxParticles * maxPointsPerTrail * 2; // Two vertices per point (left/right)
                const totalIndices = maxParticles * maxSegments * 6; // 6 indices per segment quad

                const positions = new Float32Array(totalVertices * 3);
                const colors = new Float32Array(totalVertices * 3);
                const alphas = new Float32Array(totalVertices);
                const uvs = new Float32Array(totalVertices * 2); // NEW: UV coordinates
                const trailIndices = new Uint16Array(totalIndices);

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
                geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                geometry.setIndex(new THREE.BufferAttribute(trailIndices, 1));
                geometry.setDrawRange(0, 0);

                // Pre-calculate indices
                let i = 0;
                for (let p = 0; p < maxParticles; p++) {
                    const maxPointsIndex = p * maxPointsPerTrail * 2;
                    for (let s = 0; s < maxSegments; s++) {
                        const v0 = maxPointsIndex + s * 2;       // Left vertex of current point
                        const v1 = maxPointsIndex + s * 2 + 1;   // Right vertex of current point
                        const v2 = maxPointsIndex + s * 2 + 2;   // Left vertex of next point
                        const v3 = maxPointsIndex + s * 2 + 3;   // Right vertex of next point

                        // Quad 1 (v0, v1, v3)
                        trailIndices[i++] = v0;
                        trailIndices[i++] = v1;
                        trailIndices[i++] = v3;

                        // Quad 2 (v3, v2, v0)
                        trailIndices[i++] = v3;
                        trailIndices[i++] = v2;
                        trailIndices[i++] = v0;
                    }
                }
                geometry.index.needsUpdate = true;

                return geometry;
            }


            init() {
                if (!window.THREE) return;
                const container = document.getElementById('viewport-container');
                if (!container) return;

                this.scene = new THREE.Scene();
                // Initialize background color
                this.scene.background = new THREE.Color(BACKGROUND_COLORS[this.backgroundIndex].color);



                this.gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
                this.gridHelper.position.y = this.groundHeight; // Set to default -1.0
                this.scene.add(this.gridHelper);

                this.camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
                this.camera.position.set(5, 5, 10);
                this.camera.lookAt(0, 2, 0);

                this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('render-canvas'), alpha: true });
                this.renderer.sortObjects = true; // Crucial for correct transparent layering
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);

                // FIX: Use requestAnimationFrame to break the ResizeObserver loop
                new ResizeObserver(function (entries) {
                    requestAnimationFrame(function () {
                        if (this.camera && this.renderer && entries[0].contentRect.width > 0 && entries[0].contentRect.height > 0) {
                            const width = entries[0].contentRect.width;
                            const height = entries[0].contentRect.height;
                            this.camera.aspect = width / height;
                            this.camera.updateProjectionMatrix();
                            this.renderer.setSize(width, height);
                        }
                    }.bind(this));
                }.bind(this)).observe(container);

                this.initParticles();
                this.setupControls(this.renderer.domElement);

                // Initialize G-Force button state and Repeat button state
                this.updateGForceButton();
                this.updateRepeatButton();

                this.isReady = true;
                this.animate();
            }

            // Setup OrbitControls
            setupControls(dom) {
                if (window.THREE && window.THREE.OrbitControls) {
                    this.controls = new THREE.OrbitControls(this.camera, dom);

                    this.controls.enableDamping = true; // Enable smooth inertia
                    this.controls.dampingFactor = 0.05;
                    this.controls.screenSpacePanning = true;
                    this.controls.target.set(0, 2, 0); // Center the orbit target slightly above ground
                    this.controls.update();

                    // Update the instruction text
                    const controlsHint = document.getElementById('debug-info').nextElementSibling;
                    if (controlsHint) {
                        controlsHint.innerHTML = 'LMB: Orbit | RMB: Pan | Wheel: Zoom';
                    }
                } else {
                    console.warn("OrbitControls not loaded or available.");
                }
            }

            initParticles() {
                // Generate Default Texture (Glow)
                const cvs = document.createElement('canvas');
                cvs.width = 64; cvs.height = 64;
                const ctx = cvs.getContext('2d');
                const grd = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                grd.addColorStop(0, 'rgba(255,255,255,1)');
                grd.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, 64, 64);
                this.defaultTexture = new THREE.CanvasTexture(cvs);

                // --- 1. POINTS MATERIAL (Billboard Sprites) ---
                this.baseShaderMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        tex1: { value: null }, // <--- NEW
                        tex2: { value: null },
                        tex3: { value: null },
                        tex4: { value: null }
                    },
                    vertexShader: `
        attribute float size;
        attribute vec3 customColor;
        attribute float alpha;
        attribute float rotation;
        attribute vec2 scale; 
        attribute vec4 spriteRect; // x, y, width, height
        varying vec4 vSpriteRect;
        attribute float texIndex; 
        varying float vTexIndex;
        varying vec3 vColor;
        varying float vAlpha;
        varying float vRotation;
        varying vec2 vScale; 
        
        void main() {
            vColor = customColor;
            vAlpha = alpha;
            vRotation = rotation;
            vScale = scale; // Pass scale factor to fragment
            vSpriteRect = spriteRect;
            vTexIndex = texIndex;
            
            vec4 mv = modelViewMatrix * vec4(position, 1.0);
            
            // gl_PointSize needs the largest size dimension to ensure the stretched sprite fits
            gl_PointSize = size * (300.0 / -mv.z); 
            
            gl_Position = projectionMatrix * mv;
        }
    `,
                    fragmentShader: `
        uniform sampler2D tex1;
        uniform sampler2D tex2;
        uniform sampler2D tex3;
        uniform sampler2D tex4;
        varying vec3 vColor;
        varying float vAlpha;
        varying float vRotation;
        varying vec2 vScale; 
        varying vec4 vSpriteRect;
        varying float vTexIndex;

        void main() {
    // 1. Get standard centered coords (-0.5 to 0.5)
            vec2 p = gl_PointCoord - 0.5;

            // 2. Rotate
            float cosR = cos(vRotation);
            float sinR = sin(vRotation);
            vec2 rotP;
            rotP.x = p.x * cosR - p.y * sinR;
            rotP.y = p.x * sinR + p.y * cosR;

            // 3. SPRITERECT MAPPING
            // vSpriteRect contains Normalized Bounds (e.g. -0.25 to 0.25)
            float L = vSpriteRect.x;
            float T = vSpriteRect.y;
            float R = vSpriteRect.z;
            float B = vSpriteRect.w;

            // 4. Clip (Discard pixels outside the defined rectangle)
            // Note: We check min/max because L might be > R depending on user input
            float minX = min(L, R);
            float maxX = max(L, R);
            float minY = min(B, T);
            float maxY = max(B, T);

            if (rotP.x < minX || rotP.x > maxX || rotP.y < minY || rotP.y > maxY) {
                discard;
            }

            // 5. Map to UV (0 to 1)
            // We map the current position relative to the L->R and B->T span
            vec2 finalUV;
            finalUV.x = (rotP.x - L) / (R - L);
            // Flip Y for standard texture coords (Top to Bottom)
            finalUV.y = 1.0 - (rotP.y - B) / (T - B); 

            // 6. Sample Texture
            vec4 t;
            if (vTexIndex < 0.5) t = texture2D(tex1, finalUV);
            else if (vTexIndex < 1.5) t = texture2D(tex2, finalUV);
            else if (vTexIndex < 2.5) t = texture2D(tex3, finalUV);
            else t = texture2D(tex4, finalUV);
            
            if(t.a < 0.01) discard;
            gl_FragColor = vec4(vColor * t.rgb, vAlpha * t.a);
        }
    `,
                    transparent: true,
                    blending: THREE.NormalBlending,
                    depthWrite: false,
                    depthTest: true,
                    alphaTest: 0.05
                });

                // --- 2. TRAIL RIBBON MATERIAL TEMPLATE (NEW) ---
                this.baseTrailMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        tex: { value: null }
                    },
                    vertexShader: `
                        attribute vec3 color;
                        attribute float alpha;
                        // attribute vec2 uv; // REMOVED REDEFINITION
                        varying vec3 vColor;
                        varying float vAlpha;
                        varying vec2 vUv;
                        
                        void main() {
                            // Standard attributes are automatically available: position, uv, color
                            vColor = color;
                            vAlpha = alpha;
                            vUv = uv; // Now uses injected standard UV attribute
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D tex;
                        varying vec3 vColor;
                        varying float vAlpha;
                        varying vec2 vUv;
                        
                        void main() {
                            vec4 t = texture2D(tex, vUv);
                            // Blend texture color with vertex color and fade out using alpha
                            vec3 finalColor = vColor * t.rgb;
                            float finalAlpha = vAlpha * t.a; 
                            
                            if (finalAlpha < 0.01) discard;
                            gl_FragColor = vec4(finalColor, finalAlpha);
                        }
                    `,
                    transparent: true,
                    // Use Additive or Normal blending based on the emitter setting (set in setActiveSystem)
                    blending: THREE.NormalBlending,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });


                // Initialize the reusable particle pool
                for (let i = 0; i < this.maxParticles; i++) this.particlePool.push(new Particle());
            }

            setActiveSystem(sys) {
                this.activeSystem = sys;
                const stat = document.getElementById('sim-status');
                if (stat) stat.innerText = sys ? `System: ${sys.name}` : "No System Selected";

                this.reset();

                // --- CLEAR OLD MESHES ---
                for (var id in this.textureMeshes) {
                    if (this.textureMeshes.hasOwnProperty(id)) {
                        var group = this.textureMeshes[id];
                        this.scene.remove(group.mesh);
                        group.material.dispose();
                        group.geometry.dispose();
                    }
                }
                this.textureMeshes = {};

                // --- CLEAR OLD TRAIL MESHES ---
                for (var id in this.trailMeshes) {
                    if (this.trailMeshes.hasOwnProperty(id)) {
                        var group = this.trailMeshes[id];
                        this.scene.remove(group.mesh);
                        group.material.dispose();
                        group.geometry.dispose();
                    }
                }
                this.trailMeshes = {};

                if (sys) {
                    if (!sys.emitters) sys.emitters = [];
                    // Ensure emittersState is fully recreated for the new system
                    this.emittersState = sys.emitters.map(function (e) { return { timer: 0, time: 0, emittedSingle: false }; });

                    // --- NEW: Global Render Order Counter ---
                    // Starts at 0, increments for every mesh to force specific draw order
                    let currentRenderOrder = 0;

                    // --- NEW: Loop strictly through Emitters ---
                    sys.emitters.forEach(function (em) {
                        const textureName = (em.texture || 'null').toLowerCase();
                        const hasTrail = em.infos.some(function (i) { return i.type === 'FX_INFO_TRAIL_DATA'; });

                        // Load textures for this specific emitter
                        const tex1 = this.textures[textureName] || this.defaultTexture;
                        const tex2 = this.textures[(em.texture2 || 'null').toLowerCase()] || this.defaultTexture;
                        const tex3 = this.textures[(em.texture3 || 'null').toLowerCase()] || this.defaultTexture;
                        const tex4 = this.textures[(em.texture4 || 'null').toLowerCase()] || this.defaultTexture;

                        // --- Points Mesh Setup ---
                        var pointMaterial = this.baseShaderMaterial.clone();
                        pointMaterial.uniforms.tex1.value = tex1;
                        pointMaterial.uniforms.tex2.value = tex2;
                        pointMaterial.uniforms.tex3.value = tex3;
                        pointMaterial.uniforms.tex4.value = tex4;

                        // Apply Blending
                        const src = em.srcBlend || 4;
                        const dst = em.dstBlend || 5;

                        const blendMap = {
                            1: THREE.OneFactor, 2: THREE.ZeroFactor, 3: THREE.SrcColorFactor,
                            4: THREE.SrcAlphaFactor, 5: THREE.OneMinusSrcAlphaFactor, 6: THREE.OneMinusSrcColorFactor
                        };

                        pointMaterial.blending = THREE.CustomBlending;
                        pointMaterial.blendEquation = THREE.AddEquation;
                        pointMaterial.srcFactor = blendMap[src] || THREE.SrcAlphaFactor;
                        pointMaterial.dstFactor = blendMap[dst] || THREE.OneMinusSrcAlphaFactor;
                        pointMaterial.needsUpdate = true;
                        pointMaterial.transparent = true;
                        pointMaterial.depthWrite = false;

                        // Create and add Points Mesh
                        const pointGeometry = this.createParticleGeometry(this.maxParticles);
                        const pointMesh = new THREE.Points(pointGeometry, pointMaterial);
                        pointMesh.frustumCulled = false;

                        // --- Trail Mesh Setup (NEW) ---
                        if (hasTrail) {
                            var trailMaterial = this.baseTrailMaterial.clone();
                            trailMaterial.uniforms.tex.value = tex1;
                            // Match blending
                            trailMaterial.blending = pointMaterial.blending;
                            trailMaterial.srcFactor = pointMaterial.srcFactor;
                            trailMaterial.dstFactor = pointMaterial.dstFactor;

                            const trailGeometry = this.createTrailGeometry(this.maxParticles, this.maxTrailSegments);
                            const trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
                            trailMesh.frustumCulled = false;

                            // ASSIGN ORDER: Trail draws first
                            trailMesh.renderOrder = currentRenderOrder++;

                            // Key by EMITTER ID, not texture name
                            this.trailMeshes[em._id] = {
                                mesh: trailMesh, geometry: trailGeometry, material: trailMaterial, particles: []
                            };
                            this.scene.add(trailMesh);
                        }

                        // ASSIGN ORDER: Points draw second (on top of its own trail)
                        pointMesh.renderOrder = currentRenderOrder++;

                        // Key by EMITTER ID, not texture name
                        this.textureMeshes[em._id] = {
                            mesh: pointMesh, geometry: pointGeometry, material: pointMaterial, particles: []
                        };
                        this.scene.add(pointMesh);

                    }.bind(this));
                }
            }

            reset() {
                this.particlePool.forEach(function (p) { p.active = false; p.history.length = 0; });

                // Reset the state for all emitters
                if (this.emittersState) {
                    this.emittersState.forEach(function (s) {
                        s.timer = 0;
                        s.time = 0;
                        s.emittedSingle = false;
                    });
                }

                // Clear all drawn particles in point geometries
                for (var textureName in this.textureMeshes) {
                    if (this.textureMeshes.hasOwnProperty(textureName)) {
                        var group = this.textureMeshes[textureName];

                        // Check if attributes exist before trying to update them
                        if (group.geometry && group.geometry.attributes.size) {
                            const sz = group.geometry.attributes.size.array;
                            const rotAttr = group.geometry.attributes.rotation.array;
                            const scaleAttr = group.geometry.attributes.scale.array;

                            // Reset all size attributes to 0 to visually hide them
                            for (let i = 0; i < this.maxParticles; i++) {
                                sz[i] = 0;
                                rotAttr[i] = 0;
                                scaleAttr[i * 2] = 0;
                                scaleAttr[i * 2 + 1] = 0;
                            }
                            group.geometry.attributes.size.needsUpdate = true;
                            group.geometry.attributes.rotation.needsUpdate = true;
                            group.geometry.attributes.scale.needsUpdate = true;
                            group.geometry.setDrawRange(0, 0);
                        }
                    }
                }

                // Reset Trail Meshes
                for (var textureName in this.trailMeshes) {
                    if (this.trailMeshes.hasOwnProperty(textureName)) {
                        this.trailMeshes[textureName].geometry.setDrawRange(0, 0);
                        this.trailMeshes[textureName].mesh.visible = false;
                    }
                }

                // Reset pool index for reuse
                this.poolIndex = 0;
            }

            togglePlay() {
                this.isPlaying = !this.isPlaying;
                const btn = document.getElementById('play-btn');
                if (btn) btn.innerHTML = this.isPlaying ? '<i class="fas fa-pause"></i>' : '<i class="fas fa-play"></i>';
            }

            updateRepeatButton() {
                const btn = document.getElementById('repeat-toggle');
                if (btn) {
                    btn.classList.toggle('btn-primary', this.isRepeatEnabled);
                    btn.classList.toggle('btn-neutral', !this.isRepeatEnabled);
                    btn.title = this.isRepeatEnabled ? 'Disable System Looping' : 'Enable System Looping (Repeat)';
                }
            }

            toggleRepeat() {
                this.isRepeatEnabled = !this.isRepeatEnabled;
                this.updateRepeatButton();
                customAlert(this.isRepeatEnabled ? 'Forced Repeat Enabled' : 'Forced Repeat Disabled', 'info');
                // Force a reset to restart systems that may have stopped
                if (this.isRepeatEnabled) {
                    this.reset();
                }
            }

            toggleGrid() {
                this.isGridVisible = !this.isGridVisible;
                if (this.gridHelper) {
                    this.gridHelper.visible = this.isGridVisible;
                }

                // Update Button Visuals
                const btn = document.getElementById('grid-toggle-btn');
                if (btn) {
                    // Visual feedback: Primary color = ON, Ghost/Gray = OFF
                    if (this.isGridVisible) {
                        btn.classList.remove('btn-ghost', 'opacity-50');
                        btn.classList.add('btn-primary');
                    } else {
                        btn.classList.remove('btn-primary');
                        btn.classList.add('btn-ghost', 'opacity-50');
                    }
                }
            }

            updateGForceButton() {
                const btn = document.getElementById('gforce-btn');
                if (btn) {
                    btn.classList.toggle('btn-primary', this.isGForceEnabled);
                    btn.classList.toggle('btn-neutral', !this.isGForceEnabled);
                    btn.title = this.isGForceEnabled ? 'Disable Gravity (G-Force)' : 'Enable Gravity (G-Force)';
                }
            }

            toggleGForce() {
                this.isGForceEnabled = !this.isGForceEnabled;
                this.updateGForceButton();
                customAlert(this.isGForceEnabled ? 'Gravity Enabled' : 'Gravity Disabled', 'info');
            }

            changeBackground() {
                this.backgroundIndex = (this.backgroundIndex + 1) % BACKGROUND_COLORS.length;
                const newBg = BACKGROUND_COLORS[this.backgroundIndex];
                this.scene.background.setHex(newBg.color);

                // Update grid visibility (GridHelper)
                const isBright = newBg.color === 0xffffff;

                this.scene.traverse(function (obj) {
                    if (obj instanceof THREE.GridHelper) {
                        // Use darker lines for light backgrounds
                        const gridColor = isBright ? 0x666666 : 0x444444;
                        const subGridColor = isBright ? 0x999999 : 0x222222;

                        // NOTE: GridHelper requires updating the geometry attributes to change color
                        const colors = obj.geometry.attributes.color.array;
                        const mainColor = new THREE.Color(gridColor);
                        const subColor = new THREE.Color(subGridColor);

                        // Update colors: 0-2 (sub grid), 3-5 (main grid)
                        for (let i = 0; i < obj.geometry.attributes.color.count; i++) {
                            const isMain = i % 2 === 1; // Assuming primary lines are indices 1, 3, 5, ...
                            const color = isMain ? mainColor : subColor;
                            colors[i * 3] = color.r;
                            colors[i * 3 + 1] = color.g;
                            colors[i * 3 + 2] = color.b;
                        }

                        obj.geometry.attributes.color.needsUpdate = true;
                    }
                });

                customAlert(`Background: ${newBg.name}`, 'info');
            }


            getKeyValue(prop, time) {
                if (typeof prop === 'number') return prop;
                if (!prop || !prop.keys || !prop.keys.length) return 0;
                const keys = prop.keys;
                if (keys.length === 1) return keys[0].val;

                let i = 0;
                while (i < keys.length - 1 && keys[i + 1].time <= time) i++;

                const k1 = keys[i];
                const k2 = keys[i + 1] || k1;

                const t = (k2.time === k1.time) ? 0 : (time - k1.time) / (k2.time - k1.time);
                return k1.val + (k2.val - k1.val) * t;
            }

            // ðŸš€ REFINED FIX: GTA SA Z-up to Three.js Y-up mapping, Angle fix, and properties
            spawn(emitter) {
                const p = this.particlePool[this.poolIndex]; // Uses particlePool
                this.poolIndex = (this.poolIndex + 1) % this.maxParticles;

                p.active = true;
                p.age = 0;
                p.emitterDef = emitter;
                p.history.length = 0; // Clear history on spawn

                // --- LIFE ---
                const lifeData = emitter.infos.find(function (i) { return i.type.includes('EMLIFE'); });
                let baseLife = lifeData ? this.getKeyValue(lifeData.data.LIFE, 0) : 1.0;

                if (lifeData && lifeData.data.BIAS) {
                    const bias = this.getKeyValue(lifeData.data.BIAS, 0);
                    // Apply Random: Base + (Random(-1 to 1) * Bias)
                    baseLife += (Math.random() * 2.0 - 1.0) * bias;
                }

                p.life = baseLife;
                if (p.life <= 0) p.life = 0.001; // Safety

                //Ensure particle lives at least one simulation frame 
                // This prevents the update loop from culling it before it is ever rendered.
                if (p.life < FPS_STEP) {
                    p.life = FPS_STEP * 2;
                }

                // --- INITIAL POSITION CALCULATION (EMSIZE + EMPOS) ---
                // Start accumulator at World Origin (which is the emitter's center)
                p.position.set(0, 0, 0);

                // Vector to store the final offset accumulated from all sources (EMSIZE randomization + EMPOS offset)
                const totalOffset = new THREE.Vector3(0, 0, 0);

                // 1. Calculate EMSIZE VOLUME OFFSET (The randomization)
                const emSizeData = emitter.infos.find(function (i) { return i.type === 'FX_INFO_EMSIZE_DATA'; });
                if (emSizeData) {
                    const rad = this.getKeyValue(emSizeData.data.RADIUS, 0) || 0;
                    const minX = this.getKeyValue(emSizeData.data.SIZEMINX, 0) || 0;
                    const maxX = this.getKeyValue(emSizeData.data.SIZEMAXX, 0) || 0;
                    const minY = this.getKeyValue(emSizeData.data.SIZEMINY, 0) || 0;
                    const maxY = this.getKeyValue(emSizeData.data.SIZEMAXY, 0) || 0;
                    const minZ = this.getKeyValue(emSizeData.data.SIZEMINZ, 0) || 0;
                    const maxZ = this.getKeyValue(emSizeData.data.SIZEMAXZ, 0) || 0;

                    let randX = 0, randY = 0, randZ = 0; // SA Coordinates for randomization

                    if (rad > 1e-6) {
                        // FIX: Generate the offset in the *SA Z-up* coordinate system and then map it.
                        // Generate uniform random spherical coordinates.
                        const u = Math.random() * 2 - 1; // cos(theta) for distribution
                        const theta = Math.acos(u);       // Polar angle (spread from Z-axis)
                        const phi = Math.random() * Math.PI * 2; // Azimuthal angle

                        // Generate the vector in SA Z-up space
                        const r = Math.random() * rad; // Random distance
                        const randX = r * Math.sin(theta) * Math.cos(phi);
                        const randY = r * Math.sin(theta) * Math.sin(phi);
                        const randZ = r * Math.cos(theta); // SA Z is vertical

                        // Apply the SA Z-up mapping for the calculated volume offset and accumulate it
                        totalOffset.x += randX;
                        totalOffset.y += randZ; // SA Z (Vertical) -> 3JS Y (Vertical)
                        totalOffset.z += randY; // SA Y (Depth) -> 3JS Z (Depth)
                    }
                    else if (maxX > minX || maxZ > minZ || maxY > minY) {
                        // Bounding box volume offset
                        randX = minX + Math.random() * (maxX - minX);
                        randY = minY + Math.random() * (maxY - minY);
                        randZ = minZ + Math.random() * (maxZ - minZ);

                        // Apply the SA Z-up mapping for the calculated volume offset and add it to totalOffset
                        totalOffset.x += randX;
                        totalOffset.y += randZ; // SA Z (Vertical) -> 3JS Y (Vertical)
                        totalOffset.z += randY; // SA Y (Depth) -> 3JS Z (Depth)
                    }
                }

                // 2. Apply EMPOS OFFSET (The constant position offset)
                const posData = emitter.infos.find(function (i) { return i.type === 'FX_INFO_EMPOS_DATA'; });
                if (posData) {
                    // EMPOS X/Y/Z are fields in FX_INFO_EMPOS_DATA
                    const px = this.getKeyValue(posData.data.X, 0) || 0;
                    const py_sa = this.getKeyValue(posData.data.Y, 0) || 0;
                    const pz_sa = this.getKeyValue(posData.data.Z, 0) || 0;

                    // MAPPING: X=X, Y(Three.js)=Z(SA), Z(Three.js)=Y(SA)
                    // Accumulate EMPOS offset
                    totalOffset.x += px;
                    totalOffset.y += pz_sa;
                    totalOffset.z += py_sa;
                }

                // Final Step 1: Set p.position to the accumulated offset.
                p.position.copy(totalOffset);
                p.textureName = (emitter.texture || 'null').toLowerCase(); // Store name for switching
                // --- SPEED (With Bias) ---
                const speedData = emitter.infos.find(function (i) { return i.type.includes('EMSPEED'); });
                let speed = 0.0; // Default speed if no data exists

                if (speedData) {
                    const baseSpeed = this.getKeyValue(speedData.data.SPEED, 0);
                    // Get Bias (Variance), default to 0 if missing
                    const bias = this.getKeyValue(speedData.data.BIAS, 0) || 0;

                    // Apply Randomization: Base + (Random(-1 to 1) * Bias)
                    speed = baseSpeed + (Math.random() * 2.0 - 1.0) * bias;
                }

                const dirData = emitter.infos.find(function (i) { return i.type.includes('EMDIR'); });
                let dx = 0, dy_sa = 0, dz_sa = 1;
                if (dirData) {
                    dx = this.getKeyValue(dirData.data.DIRX, 0) || 0;
                    dy_sa = this.getKeyValue(dirData.data.DIRY, 0) || 0;
                    dz_sa = this.getKeyValue(dirData.data.DIRZ, 0) || 0;
                }

                const baseDirection = new THREE.Vector3(dx, dz_sa, dy_sa);
                if (baseDirection.lengthSq() < 1e-6) baseDirection.set(0, 1, 0);
                baseDirection.normalize();

                // --- ANGLE/CONE LOGIC (Skipped for brevity, assume full correct code here) ---
                const angleData = emitter.infos.find(function (i) { return i.type.includes('EMANGLE'); });

                if (angleData) {
                    const minAngleDeg = this.getKeyValue(angleData.data.MIN, 0) || 0;
                    let maxAngleDeg = this.getKeyValue(angleData.data.MAX, 0);
                    if (maxAngleDeg === undefined || maxAngleDeg === null) { maxAngleDeg = minAngleDeg; }

                    const minAngleRad = minAngleDeg * (Math.PI / 180);
                    const maxAngleRad = maxAngleDeg * (Math.PI / 180);
                    const angleRange = Math.max(0, maxAngleRad - minAngleRad);

                    if (angleRange > 1e-6) {
                        const randomFactor = Math.random();
                        const thetaSpread = minAngleRad + (angleRange * randomFactor);
                        const phi = Math.random() * Math.PI * 2;

                        const tempDirX = Math.sin(thetaSpread) * Math.cos(phi);
                        const tempDirY = Math.sin(thetaSpread) * Math.sin(phi);
                        const tempDirZ = Math.cos(thetaSpread);

                        const scatterDirection = new THREE.Vector3(tempDirX, tempDirY, tempDirZ);
                        const rotationToDirection = new THREE.Quaternion().setFromUnitVectors(
                            new THREE.Vector3(0, 0, 1),
                            baseDirection.clone().normalize()
                        );

                        scatterDirection.applyQuaternion(rotationToDirection);
                        baseDirection.copy(scatterDirection);
                    }
                }

                // Final Step 2: Set Velocity
                p.velocity.copy(baseDirection).normalize().multiplyScalar(speed);

                // --- INITIAL ROTATION ---
                const emRotData = emitter.infos.find(function (i) { return i.type.includes('EMROTATION'); });
                if (emRotData) {
                    const minAng = this.getKeyValue(emRotData.data.ANGLEMIN, 0);
                    let maxAng = this.getKeyValue(emRotData.data.ANGLEMAX, 0);
                    if (maxAng === undefined || maxAng === null) maxAng = minAng;

                    // Set Initial Angle
                    p.rotation = (minAng + Math.random() * (maxAng - minAng)) * (Math.PI / 180);
                } else {
                    p.rotation = 0.0;
                }

                // --- ROTATION SPEED SETUP ---
                const rotSpeedData = emitter.infos.find(function (i) { return i.type.includes('ROTSPEED'); });
                if (rotSpeedData) {
                    // GENERATE THE "BIAS" ONCE
                    // This value (e.g., 0.8) means "I will always use 80% of the Max speed"
                    p.rotRandomFactor = Math.random();

                    // Decide Direction (CW or CCW)
                    p.rotDirection = (Math.random() < 0.5) ? -1.0 : 1.0;
                } else {
                    p.rotRandomFactor = 0.0;
                    p.rotDirection = 1.0;
                }
            }

            updateParticleVisuals(p, normTime) {
                const colData = p.emitterDef.infos.find(function (i) { return i.type.includes('COLOUR'); });
                if (colData) {
                    // --- Color Reading Logic ---
                    const r = this.getKeyValue(colData.data.RED, normTime) / 255;
                    const g = this.getKeyValue(colData.data.GREEN, normTime) / 255;
                    const b = this.getKeyValue(colData.data.BLUE, normTime) / 255;
                    const a = this.getKeyValue(colData.data.ALPHA, normTime) / 255;
                    p.color.setRGB(r, g, b);
                    p.alpha = a;
                    p.color.multiplyScalar(2);
                    if (colData.data.BIAS) {
                        const biasRaw = this.getKeyValue(colData.data.BIAS, normTime);

                        // Normalize bias from 0-255 to 0.0-1.0
                        //  const biasNorm = biasRaw / 255.0;

                        //  if (biasNorm > 0) {
                        //      // Add to existing RGB values
                        //      p.color.r += biasNorm;
                        //      p.color.g += biasNorm;
                        //      p.color.b += biasNorm;
                        //  }

                    }
                } else {
                    p.color.setRGB(1, 1, 1);
                    p.alpha = 1;
                }

                const sizeData = p.emitterDef.infos.find(function (i) { return i.type.includes('_SIZE_DATA'); });
                if (sizeData && sizeData.data.SIZEX && sizeData.data.SIZEY) {

                    // 1. Read Base Size Values
                    const baseSizeX = this.getKeyValue(sizeData.data.SIZEX, normTime);
                    const baseSizeY = this.getKeyValue(sizeData.data.SIZEY, normTime);

                    // 2. Read Bias Values
                    let biasX = 0;
                    let biasY = 0;

                    if (sizeData.data.SIZEXBIAS) {
                        biasX = this.getKeyValue(sizeData.data.SIZEXBIAS, normTime);
                    }
                    if (sizeData.data.SIZEYBIAS) {
                        biasY = this.getKeyValue(sizeData.data.SIZEYBIAS, normTime);
                    }

                    // 3. Determine Final Size and Randomization
                    const sizeBoost = 2.0;

                    // Apply randomization to X and Y independently based on their bias
                    const finalSizeX = Math.max(0.01, (baseSizeX + (Math.random() * 2 - 1) * biasX) * sizeBoost);
                    const finalSizeY = Math.max(0.01, (baseSizeY + (Math.random() * 2 - 1) * biasY) * sizeBoost);

                    p.sizeX = finalSizeX;
                    p.sizeY = finalSizeY;

                    // Set p.size to the maximum dimension for gl_PointSize (since it controls the bounding box)
                    p.size = Math.max(p.sizeX, p.sizeY);

                } else {
                    // Default fallback
                    p.sizeX = 1.0;
                    p.sizeY = 1.0;
                    p.size = 1.0;
                }

            }

            updateTrailRenderer() {
                if (!this.camera) return;

                const camPos = this.camera.position;

                // Camera Basis Vectors
                const camMatrix = this.camera.matrixWorld;
                const camRight = new THREE.Vector3();
                const camUp = new THREE.Vector3();
                camRight.setFromMatrixColumn(camMatrix, 0);
                camUp.setFromMatrixColumn(camMatrix, 1);

                // Temps
                const toCam = new THREE.Vector3();
                const segDir = new THREE.Vector3();
                const right = new THREE.Vector3();
                const p1 = new THREE.Vector3();
                const p2 = new THREE.Vector3();
                const prevRight = new THREE.Vector3();

                // Projection Temps
                const partRight = new THREE.Vector3();
                const partUp = new THREE.Vector3();

                // Fallbacks
                const worldUp = new THREE.Vector3(0, 1, 0);
                const worldAxisX = new THREE.Vector3(1, 0, 0);

                for (var textureName in this.trailMeshes) {
                    if (this.trailMeshes.hasOwnProperty(textureName)) {
                        var group = this.trailMeshes[textureName];
                        const particles = this.textureMeshes[textureName].particles;

                        if (!particles || particles.length === 0) {
                            group.mesh.visible = false;
                            continue;
                        }

                        const positions = group.geometry.attributes.position.array;
                        const colors = group.geometry.attributes.color.array;
                        const alphas = group.geometry.attributes.alpha.array;
                        const uvs = group.geometry.attributes.uv.array;
                        const indices = group.geometry.index.array;

                        let vertIdx = 0;
                        let indIdx = 0;
                        let particleBaseVertIndex = 0;

                        particles.forEach(function (p) {
                            if (!p.active) return;

                            // 1. Gather Points
                            const rawPoints = [{
                                pos: p.position,
                                sizeX: p.sizeX,
                                sizeY: p.sizeY,
                                rot: p.rotation
                            }].concat(p.history);

                            // 2. Cleaning Pass (Fix Zero-Point Artifacts)
                            const cleanPoints = [];
                            if (rawPoints.length > 0) cleanPoints.push(rawPoints[0]);
                            for (let k = 1; k < rawPoints.length; k++) {
                                const last = cleanPoints[cleanPoints.length - 1];
                                const curr = rawPoints[k];
                                if (last.pos.distanceToSquared(curr.pos) > 0.0001) {
                                    cleanPoints.push(curr);
                                }
                            }

                            const totalPoints = cleanPoints.length;
                            if (totalPoints < 2) return;

                            const baseAlpha = p.alpha;
                            prevRight.set(0, 0, 0);

                            for (let i = 0; i < totalPoints; i++) {
                                const pt = cleanPoints[i];
                                p1.copy(pt.pos);

                                // --- A. Normal Calculation ---
                                if (i < totalPoints - 1) {
                                    p2.copy(cleanPoints[i + 1].pos);
                                    segDir.subVectors(p2, p1);
                                } else {
                                    segDir.subVectors(p1, cleanPoints[i - 1].pos);
                                }
                                segDir.normalize();

                                toCam.subVectors(camPos, p1).normalize();
                                right.crossVectors(segDir, toCam);

                                // Singularity Fix
                                if (right.lengthSq() < 0.001) {
                                    if (prevRight.lengthSq() > 0.1) {
                                        right.copy(prevRight);
                                    } else {
                                        right.crossVectors(segDir, worldUp);
                                        if (right.lengthSq() < 0.001) right.crossVectors(segDir, worldAxisX);
                                    }
                                }
                                right.normalize();
                                if (isNaN(right.x)) right.set(1, 0, 0);
                                prevRight.copy(right);

                                // --- B. PROJECTED WIDTH (Corrected Thickness) ---
                                const cosR = Math.cos(pt.rot);
                                const sinR = Math.sin(pt.rot);

                                partRight.copy(camRight).multiplyScalar(cosR).subVectors(partRight, partUp.copy(camUp).multiplyScalar(sinR));
                                partUp.copy(camRight).multiplyScalar(sinR).addVectors(partUp, camUp.clone().multiplyScalar(cosR));

                                const contribX = Math.abs(right.dot(partRight)) * pt.sizeX;
                                const contribY = Math.abs(right.dot(partUp)) * pt.sizeY;

                                // CORRECTION: Multiplier changed to 0.25 (Factor of 2 thinner than before)
                                // This accounts for p.sizeX being the diameter + Boost, while we need visual half-width.
                                const halfWidth = (contribX + contribY) * 0.25;

                                // --- C. Extrude ---
                                positions[vertIdx * 3 + 0] = p1.x - (right.x * halfWidth);
                                positions[vertIdx * 3 + 1] = p1.y - (right.y * halfWidth);
                                positions[vertIdx * 3 + 2] = p1.z - (right.z * halfWidth);

                                positions[(vertIdx + 1) * 3 + 0] = p1.x + (right.x * halfWidth);
                                positions[(vertIdx + 1) * 3 + 1] = p1.y + (right.y * halfWidth);
                                positions[(vertIdx + 1) * 3 + 2] = p1.z + (right.z * halfWidth);

                                // --- D. Attributes ---
                                colors[vertIdx * 3 + 0] = p.color.r; colors[vertIdx * 3 + 1] = p.color.g; colors[vertIdx * 3 + 2] = p.color.b;
                                colors[(vertIdx + 1) * 3 + 0] = p.color.r; colors[(vertIdx + 1) * 3 + 1] = p.color.g; colors[(vertIdx + 1) * 3 + 2] = p.color.b;

                                const fade = 1.0;// - (i / (totalPoints - 1));
                                alphas[vertIdx] = baseAlpha * fade;
                                alphas[vertIdx + 1] = baseAlpha * fade;

                                const vCoord = i / (totalPoints - 1);
                                uvs[vertIdx * 2 + 0] = 0.0; uvs[vertIdx * 2 + 1] = vCoord;
                                uvs[(vertIdx + 1) * 2 + 0] = 1.0; uvs[(vertIdx + 1) * 2 + 1] = vCoord;

                                vertIdx += 2;
                            }

                            // Indices
                            for (let i = 0; i < totalPoints - 1; i++) {
                                const base = particleBaseVertIndex + (i * 2);
                                indices[indIdx++] = base; indices[indIdx++] = base + 1; indices[indIdx++] = base + 2;
                                indices[indIdx++] = base + 1; indices[indIdx++] = base + 3; indices[indIdx++] = base + 2;
                            }
                            particleBaseVertIndex = vertIdx;
                            p.alpha = 0;
                        });

                        group.geometry.setDrawRange(0, indIdx);
                        group.geometry.attributes.position.needsUpdate = true;
                        group.geometry.attributes.color.needsUpdate = true;
                        group.geometry.attributes.alpha.needsUpdate = true;
                        group.geometry.attributes.uv.needsUpdate = true;
                        group.geometry.index.needsUpdate = true;
                        group.mesh.visible = (indIdx > 0);
                    }
                }
            }
            //p.alpha = 0;
            update(dt) {
                if (!this.isReady || !this.isPlaying || !this.activeSystem) return;

                // 1. Fixed Time Step Setup
                var simulationStep = FPS_STEP; // Integration step is always 1/30th of a second
                this.timeAccumulator += dt * this.timeScale * 0.8; // Time accumulated is modified by timescale

                var steps = 0;
                while (this.timeAccumulator >= simulationStep && steps < 4) { // Fixed step size for integration
                    this.integrate_step(simulationStep);
                    this.timeAccumulator -= simulationStep;
                    steps++;
                }

                // Render interpolation (using the remaining accumulated time) is skipped for particle editors,
                // we just draw the last calculated simulation step.
            }

            integrate_step(fixedDt) {
                this.activeSystem.emitters.forEach(function (em, idx) {
                    if (!this.emittersState[idx]) this.emittersState[idx] = { timer: 0, time: 0, emittedSingle: false };
                    const state = this.emittersState[idx];

                    state.time += fixedDt;

                    // --- CRITICAL CHECK FOR LOOPING ---
                    // PlayMode 0 is loop forever. PlayMode 2 is play once and stop.
                    if (this.activeSystem.length > 0 && state.time >= this.activeSystem.length) {
                        // Check if PlayMode is NOT loop forever (0) OR if forced repeat is enabled
                        if (this.activeSystem.playMode === 0 || this.isRepeatEnabled) {
                            // Loop forever or forced repeat: reset time

                            // Use system length + interval to calculate next loop point accurately
                            const systemDuration = this.activeSystem.length + this.activeSystem.loopInterval;

                            if (state.time >= systemDuration) {
                                state.time %= systemDuration;
                                state.emittedSingle = false; // Reset burst flag for looping systems
                            } else {
                                // If inside the loop interval (after length but before length + interval), pause emission
                                return;
                            }
                        }
                        else if (this.activeSystem.playMode === 1 || this.activeSystem.playMode === 2) {
                            // Play Once: stop simulation for this emitter
                            return;
                        }
                    }

                    const rateData = em.infos.find(function (i) { return i.type === 'FX_INFO_EMRATE_DATA'; });
                    if (rateData && rateData.data.RATE) {

                        // --- NEW DEFINITIVE BURST EMISSION LOGIC (Forces burst at t=0) ---
                        // 1. Get the INITIAL rate at t=0.000
                        const initialRate = this.getKeyValue(rateData.data.RATE, 0.0);

                        // 2. Get the current rate at the current time (for accumulation)
                        const currentRate = this.getKeyValue(rateData.data.RATE, state.time);


                        // Check if we need to force a large, immediate burst (One-Shot)
                        if (!state.emittedSingle && initialRate > 500) {
                            const totalParticlesToEmit = Math.ceil(initialRate * 0.5); // 0.02s is a safe burst window

                            for (let k = 0; k < totalParticlesToEmit; k++) {
                                this.spawn(em);
                            }
                            state.emittedSingle = true; // Mark as burst emitted
                        }
                        // --- END NEW DEFINITIVE BURST EMISSION LOGIC ---


                        // STANDARD EMISSION (Accumulator based on the currentRate)
                        if (currentRate > 0) {
                            const interval = 1.0 / currentRate;
                            state.timer += fixedDt;
                            while (state.timer >= interval) {
                                this.spawn(em);
                                state.timer -= interval;
                            }
                        } else {
                            // Fallback for simple single spawn decals (already handled by emittedSingle flag)
                        }
                    } else {
                        if (!state.emittedSingle) {
                            this.spawn(em);
                            state.emittedSingle = true;
                        }
                    }
                }.bind(this)); // Bind context for forEach

                // --- CLEAR PARTICLE GROUPS AND UPDATE PHYSICS ---
                // Clear previous frame's groupings
                for (var textureName in this.textureMeshes) {
                    if (this.textureMeshes.hasOwnProperty(textureName)) {
                        this.textureMeshes[textureName].particles.length = 0;
                    }


                }

                let activeCount = 0;

                let HasTrail = 0;
                // Loop through the entire particle pool, update physics, and group by texture
                for (let i = 0; i < this.maxParticles; i++) {
                    const p = this.particlePool[i]; // Uses particlePool
                    if (!p.active) continue;

                    p.age += fixedDt;
                    if (p.age >= p.life) {
                        p.active = false;
                        continue;
                    }

                    activeCount++;
                    const norm = p.age / p.life;


                    // --- TRAIL HISTORY UPDATE (25 FPS STRICT) ---
                    var trailData = p.emitterDef.infos.find(function (i) { return i.type === 'FX_INFO_TRAIL_DATA'; });
                    if (trailData) {
                        const trailParam = app.sim.getKeyValue(trailData.data.TRAILTIME, norm);
                        const maxHistory = Math.max(0, Math.floor(trailParam));
                        if (maxHistory > 1) {
                            HasTrail = 1;
                        }
                        if (maxHistory > 0) {
                            p.trailTimer += fixedDt; // Use fixedDt!

                            // 25 FPS Throttling
                            if (p.trailTimer >= 0.04) {
                                p.trailTimer -= 0.04;

                                // Zero-Point / Duplicate Guard
                                const MIN_DIST_SQ = 0.0001;
                                let shouldPush = false;

                                if (p.history.length === 0) {
                                    shouldPush = true;
                                } else {
                                    const lastPos = p.history[0].pos;
                                    if (p.position.distanceToSquared(lastPos) > MIN_DIST_SQ) {
                                        shouldPush = true;
                                    }
                                }

                                if (shouldPush) {
                                    p.history.unshift({
                                        pos: p.position.clone(),
                                        sizeX: p.sizeX,      // Store Width
                                        sizeY: p.sizeY,      // Store Height
                                        rot: p.rotation      // Store Rotation
                                    });

                                    if (p.history.length > maxHistory) {
                                        p.history.length = maxHistory;
                                    }
                                }
                            }
                        } else {
                            p.history.length = 0;
                            p.trailTimer = 0.0;
                        }
                    } else {
                        p.history.length = 0;
                        p.trailTimer = 0.0;
                    }
                    // --- FORCE & G-FORCE (Mapped and Integrated) ---
                    const forceData = p.emitterDef.infos.find(function (i) { return i.type === 'FX_INFO_FORCE_DATA'; });

                    // 1. Get base force components (SA Z-up)
                    let fx = 0, fy_sa = 0, fz_sa = 0;
                    if (forceData) {
                        fx = this.getKeyValue(forceData.data.FORCEX, norm) || 0;
                        fy_sa = this.getKeyValue(forceData.data.FORCEY, norm) || 0;
                        fz_sa = this.getKeyValue(forceData.data.FORCEZ, norm) || 0;
                    }

                    // 2. Apply constant G-Force if no Z-force is specified in the FXP data
                    const fz_component_defined = (forceData && forceData.data.FORCEZ !== undefined);

                    // MODIFIED: Only apply G-Force if it is enabled 
                    if (this.isGForceEnabled && (!fz_component_defined || (typeof fz_sa === 'number' && Math.abs(fz_sa) < 1e-6))) {
                        fz_sa += G_FORCE_PROXY; // Apply gravity (negative Z in SA coords)
                    }

                    // 3. Apply force changes to velocity (Mapped to Three.js Y-up)
                    // MAPPING: X=X, Y(Three.js)=Z(SA), Z(Three.js)=Y(SA)
                    p.velocity.x += fx * fixedDt;
                    p.velocity.y += fz_sa * fixedDt; // Vertical force
                    p.velocity.z += fy_sa * fixedDt; // Horizontal depth force

                 // --- FRICTION (FX_INFO_FRICTION_DATA) ---
                    const frictionData = p.emitterDef.infos.find(function (i) { return i.type === 'FX_INFO_FRICTION_DATA'; });
                    if (frictionData) {
                        // FIX: Check for 'FRICTION' key first (used by Editor), fallback to 'MIN' (Legacy/Import)
                        let fKey = frictionData.data.FRICTION;
                        if (!fKey && frictionData.data.MIN) fKey = frictionData.data.MIN;

                        const friction = this.getKeyValue(fKey, norm);
                        
                        // Apply friction
                        // Only apply if friction > 0 to save math operations
                        if (friction > 0.001) {
                            p.velocity.multiplyScalar(Math.pow(friction, fixedDt * 60));
                        }
                    }

                    const jitterData = p.emitterDef.infos.find(function (i) { return i.type === 'FX_INFO_JITTER_DATA'; });
                    if (jitterData) {
                        const jAmt = this.getKeyValue(jitterData.data.JITTERFACTOR, norm);

                        if (jAmt > 0) {
                            // Apply random offset to position directly
                            // We multiply by fixedDt to ensure the intensity is consistent regardless of step size
                            p.position.x += (Math.random() - 0.5) * jAmt * fixedDt * 10.0;
                            p.position.y += (Math.random() - 0.5) * jAmt * fixedDt * 10.0;
                            p.position.z += (Math.random() - 0.5) * jAmt * fixedDt * 10.0;
                        }
                    }


                    // --- ATTRACTION POINT (Black Hole Effect) ---
                    const attractData = p.emitterDef.infos.find(function (i) { return i.type === 'FX_INFO_ATTRACTPT_DATA'; });
                    if (attractData) {
                        // 1. Get Target Position (SA Coordinates)
                        const tx = this.getKeyValue(attractData.data.POSX, norm) || 0;
                        const ty_sa = this.getKeyValue(attractData.data.POSY, norm) || 0;
                        const tz_sa = this.getKeyValue(attractData.data.POSZ, norm) || 0;

                        // 2. Map to Three.js Y-Up (X=X, Y=Z_sa, Z=Y_sa)
                        const targetPos = new THREE.Vector3(tx, tz_sa, ty_sa);

                        // 3. Calculate Direction
                        // Vector from Particle TO Target
                        const forceVec = new THREE.Vector3().subVectors(targetPos, p.position);
                        const distSq = forceVec.lengthSq();

                        if (distSq > 0.0001) {
                            forceVec.normalize();

                            // 4. Apply Force
                            const forceAmt = this.getKeyValue(attractData.data.FORCE, norm) || 0;

                            // Add to velocity (Force * Direction * dt)
                            // You might want to multiply by a constant (e.g. 50) if the effect is too weak 
                            // as GTA units can be arbitrary.
                            p.velocity.addScaledVector(forceVec, forceAmt * fixedDt * 10.0);
                        }
                    }

                    // --- WIND (Aerodynamic Drag) ---
                    const windData = p.emitterDef.infos.find(function (i) { return i.type === 'FX_INFO_WIND_DATA'; });
                    if (windData) {
                        // 1. Get how susceptible this particle is to wind
                        const windFactor = this.getKeyValue(windData.data.WINDFACTOR, norm);

                        if (windFactor > 0.0) {
                            // NEW LOGIC: Pure Additive Force
                            // If globalWind is 0, nothing is added. Velocity remains unchanged.
                            p.velocity.x += this.globalWind.x * windFactor * fixedDt;
                            p.velocity.z += this.globalWind.z * windFactor * fixedDt;
                        }
                    }

                    // --- UPDATE POSITION & ROTATION ---
                    p.position.addScaledVector(p.velocity, fixedDt);
                    p.rotation += p.rotSpeed * fixedDt; // Apply rotation speed

                    // Store the current normalized velocity vector for the shader (used for rotation/alignment)
                    if (p.velocity.lengthSq() > 1e-6) {
                        p.dirVelocity.copy(p.velocity).normalize();
                    }

                    // --- APPLY ROTATION SPEED ---
                    const rotSpeedData = p.emitterDef.infos.find(function (i) { return i.type.includes('ROTSPEED'); });

                    if (rotSpeedData) {
                        let min, max;

                        // 1. Get the Time-Based values for Min and Max based on direction
                        if (p.rotDirection < 0) {
                            // Clockwise Curves
                            min = this.getKeyValue(rotSpeedData.data.MINCW, norm);
                            max = this.getKeyValue(rotSpeedData.data.MAXCW, norm);
                        } else {
                            // Counter-Clockwise Curves
                            min = this.getKeyValue(rotSpeedData.data.MINCCW, norm);
                            max = this.getKeyValue(rotSpeedData.data.MAXCCW, norm);
                        }

                        // Safety fallback
                        if (max === undefined || max === null) max = min;

                        // 2. Apply the Bias we chose at spawn
                        // Speed = CurveMin + (CurveDiff * StoredBias)
                        const degSpeed = min + (max - min) * p.rotRandomFactor;

                        // 3. Apply
                        p.rotation += degSpeed * (Math.PI / 180) * p.rotDirection * fixedDt;
                    }

                    // --- GROUND COLLISION ---
                    const collideData = p.emitterDef.infos.find(function (i) { return i.type === 'FX_INFO_GROUNDCOLLIDE_DATA'; });

                    // Use 'this.groundHeight' instead of 0
                    if (collideData && p.position.y <= this.groundHeight) {
                        const bounce = this.getKeyValue(collideData.data.BOUNCE, norm);
                        const friction = this.getKeyValue(collideData.data.SPEEDMULT, norm);

                        p.position.y = this.groundHeight; // Snap to dynamic floor

                        if (p.velocity.y < 0) {
                            p.velocity.y = -p.velocity.y * bounce;
                        }
                        p.velocity.x *= friction;
                        p.velocity.z *= friction;
                    }


                    this.updateParticleVisuals(p, norm);

                    // Group particle by its Emitter ID (not texture name)
                    const pointGroup = this.textureMeshes[p.emitterDef._id];
                    if (pointGroup) {
                        pointGroup.particles.push(p);
                    }
                }
                // --- UPDATE TRAIL RENDERER ---
                if (HasTrail) {
                    this.updateTrailRenderer();
                }


                // --- UPDATE GEOMETRY BUFFERS PER TEXTURE GROUP (ES5 compatible iteration) ---
                for (var textureName in this.textureMeshes) {
                    if (this.textureMeshes.hasOwnProperty(textureName)) {
                        var group = this.textureMeshes[textureName];
                        const { geometry, particles } = group;

                        if (!geometry || !geometry.attributes.position) continue;

                        const posAttr = geometry.attributes.position.array;
                        const colAttr = geometry.attributes.customColor.array;
                        const szAttr = geometry.attributes.size.array;
                        const alpAttr = geometry.attributes.alpha.array;
                        const rotAttr = geometry.attributes.rotation.array;
                        const scaleAttr = geometry.attributes.scale.array;
                        const dirVAttr = geometry.attributes.dirVelocity.array;
                        const rectAttr = geometry.attributes.spriteRect.array;
                        const texIndexAttr = geometry.attributes.texIndex.array;
                        let meshParticleCount = 0;

                        particles.forEach(function (p, index) {
                            const norm = p.age / p.life;

                            // --- CALCULATE NOISE OFFSET (Orbital Sine Wave) ---
                            let noiseX = 0, noiseY = 0, noiseZ = 0;

                            // 1. Find the Noise Data Block
                            const noiseData = p.emitterDef.infos.find(function (i) { return i.type === 'FX_INFO_NOISE_DATA'; });

                            if (noiseData) {
                                // 2. Get the current intensity (Amplitude) based on particle age
                                const noiseAmp = this.getKeyValue(noiseData.data.NOISE, p.age / p.life);

                                if (noiseAmp > 0) {
                                    // 3. Calculate Oscillation
                                    // 't' drives the animation speed. 
                                    // 'index' ensures every particle moves in a unique direction.
                                    const t = p.age * 5.0; // 15.0 is the frequency/speed of the shake
                                    const AmplitudeFac = 0.09;
                                    // We use different phase offsets (index * 0.x) for X, Y, Z so they are desynchronized
                                    noiseX = Math.sin(t + (index * 0.1)) * (noiseAmp * AmplitudeFac);
                                    noiseY = Math.cos(t + (index * 0.2)) * (noiseAmp * AmplitudeFac); // Use Cos for Y to create circular/orbital motion vs X
                                    noiseZ = Math.sin(t + (index * 0.3) + 1.5) * noiseAmp * AmplitudeFac; // Offset Z phase
                                }
                            }
                            // Position 
                            posAttr[index * 3] = p.position.x + noiseX;
                            posAttr[index * 3 + 1] = p.position.y + noiseY;
                            posAttr[index * 3 + 2] = p.position.z + noiseZ;

                            // Color, Alpha, Size 
                            colAttr[index * 3] = p.color.r;
                            colAttr[index * 3 + 1] = p.color.g;
                            colAttr[index * 3 + 2] = p.color.b;
                            alpAttr[index] = p.alpha;

                            // Use largest dimension for gl_PointSize
                            szAttr[index] = p.size;

                            // Rotation
                            rotAttr[index] = p.rotation;

                            // Scale (sizeX and sizeY factors)
                            // This calculation determines the aspect ratio stretch in the shader
                            scaleAttr[index * 2] = p.sizeX / p.size;     // Horizontal scaling factor (X)
                            scaleAttr[index * 2 + 1] = p.sizeY / p.size; // Vertical scaling factor (Y)

                            // Velocity Direction
                            dirVAttr[index * 3] = p.dirVelocity.x;
                            dirVAttr[index * 3 + 1] = p.dirVelocity.y;
                            dirVAttr[index * 3 + 2] = p.dirVelocity.z;

                            // --- NEW: ANIMTEX LOGIC ---
                            const animData = p.emitterDef.infos.find(function (i) { return i.type === 'FX_INFO_ANIMTEX_DATA'; });
                            let currentTexIndex = 0.0;

                            if (animData) {
                                // 1. Get raw value (GTA uses 1-based indexing: 1.0, 2.0, etc.)
                                const rawVal = app.sim.getKeyValue(animData.data.TEXID, norm);

                                // 2. Convert to 0-based for WebGL (Subtract 1.0)
                                currentTexIndex = Math.floor(rawVal - 1.0);

                                // 3. Safety Clamp (0 to 3)
                                if (currentTexIndex > 3) currentTexIndex = 3;
                                if (currentTexIndex < 0) currentTexIndex = 0;
                            }

                            texIndexAttr[index] = currentTexIndex;


                            // // --- NEW: SPRITERECT LOGIC ---
                            // const rectData = p.emitterDef.infos.find(function (i) { return i.type === 'FX_INFO_SPRITERECT_DATA'; });

                            // if (rectData) {
                            //     // Now 'this' works because of the bind below
                            //     const left = this.getKeyValue(rectData.data.LEFT, norm) || 0;
                            //     const top = this.getKeyValue(rectData.data.TOP, norm) || 1;
                            //     const right = this.getKeyValue(rectData.data.RIGHT, norm) || 1;
                            //     const bottom = this.getKeyValue(rectData.data.BOTTOM, norm) || 0;

                            //     // Buffer format: X(Left), Y(Bottom), Width, Height
                            //     rectAttr[index * 4 + 0] = left;
                            //     rectAttr[index * 4 + 1] = bottom;
                            //     rectAttr[index * 4 + 2] = right - left;
                            //     rectAttr[index * 4 + 3] = top - bottom;
                            // } else {
                            //     // Default to full texture if no data exists
                            //     rectAttr[index * 4 + 0] = 0.0;
                            //     rectAttr[index * 4 + 1] = 0.0;
                            //     rectAttr[index * 4 + 2] = 1.0;
                            //     rectAttr[index * 4 + 3] = 1.0;
                            // }

                            // --- SPRITERECT LOGIC (Geometry Bounding Box) ---
                            const rectData = p.emitterDef.infos.find(function (i) { return i.type === 'FX_INFO_SPRITERECT_DATA'; });

                            if (rectData) {
                                // 1. Get raw offsets from center (e.g., L=0.5, R=-0.5)
                                // Note: We use 'this.getKeyValue' via .bind(this)
                                const l = this.getKeyValue(rectData.data.LEFT, norm);
                                const t = this.getKeyValue(rectData.data.TOP, norm);
                                const r = this.getKeyValue(rectData.data.RIGHT, norm);
                                const b = this.getKeyValue(rectData.data.BOTTOM, norm);

                                // Defaults if values are missing
                                const L = (l !== undefined) ? l : 0.5;
                                const T = (t !== undefined) ? t : 0.5;
                                const R = (r !== undefined) ? r : -0.5;
                                const B = (b !== undefined) ? b : -0.5;

                                // 2. Calculate Bounding Box (Max distance from center 0,0)
                                // The gl_Point is a square centered at 0. It must be large enough to cover the furthest offset.
                                const maxDistX = Math.max(Math.abs(L), Math.abs(R));
                                const maxDistY = Math.max(Math.abs(T), Math.abs(B));
                                const maxRadius = Math.max(maxDistX, maxDistY);

                                // Prevent divide by zero if radius is 0
                                const diameter = (maxRadius > 0.001) ? maxRadius * 2.0 : 1.0;

                                // 3. Scale Particle Size
                                // The visual size is the Bounding Diameter * Particle Scale
                                szAttr[index] = p.size * diameter;

                                // 4. Normalize Offsets for Shader (-0.5 to 0.5 range)
                                // We divide the raw offsets by the diameter so the shader can compare them 
                                // to the standard gl_PointCoord space.
                                rectAttr[index * 4 + 0] = L / diameter;
                                rectAttr[index * 4 + 1] = T / diameter;
                                rectAttr[index * 4 + 2] = R / diameter;
                                rectAttr[index * 4 + 3] = B / diameter;

                            } else {
                                // Normalize dimensions relative to the max size (0.0 to 1.0)
                                // Example: SizeX=1, SizeY=2 -> p.size=2 -> Width=0.5, Height=1.0
                                const halfWidth = (p.sizeX / p.size) * 0.5;
                                const halfHeight = (p.sizeY / p.size) * 0.5;

                                rectAttr[index * 4 + 0] = -halfWidth;  // Left
                                rectAttr[index * 4 + 1] = halfHeight;  // Top
                                rectAttr[index * 4 + 2] = halfWidth;   // Right
                                rectAttr[index * 4 + 3] = -halfHeight; // Bottom

                                szAttr[index] = p.size;
                            }
                            meshParticleCount++;

                        }.bind(this));

                        // Fill the remaining unused space with size 0 (optional cleanup/safety)
                        for (let i = meshParticleCount; i < this.maxParticles; i++) {
                            szAttr[i] = 0;
                        }


                        // Update draw range and attributes
                        geometry.setDrawRange(0, meshParticleCount);

                        // Mark buffers as needing update
                        geometry.attributes.position.needsUpdate = true;
                        geometry.attributes.customColor.needsUpdate = true;
                        geometry.attributes.alpha.needsUpdate = true;
                        geometry.attributes.size.needsUpdate = true;
                        geometry.attributes.rotation.needsUpdate = true;
                        geometry.attributes.scale.needsUpdate = true;
                        geometry.attributes.dirVelocity.needsUpdate = true;
                        geometry.attributes.spriteRect.needsUpdate = true;
                        geometry.attributes.texIndex.needsUpdate = true;
                    }
                }

                const dbg = document.getElementById('debug-info');
                if (dbg) dbg.innerText = `Particles: ${activeCount}`;
            }

            animate() {
                requestAnimationFrame(this.animate);
                let dt = this.clock.getDelta();

                if (dt > 0.1) {
                    dt = 0.1;
                }
                this.update(dt);

                // Update OrbitControls
                if (this.controls) {
                    this.controls.update();
                }

                if (this.renderer && this.scene && this.camera) {
                    this.renderer.render(this.scene, this.camera);
                }
            }
        }

        // --- 3. UI CONTROLLER ---
        let selectTimeout = null;

        // Changed from 'const app = {}' to 'var app = {}' for safer global access across function definitions
        // It's defined here and initialized later to ensure all functions that use it can see it.
        var app = {
            data: null,
            selectedId: null,
            texTargetObj: null,  // The Emitter object being edited
            texTargetProp: null, // The property string ('texture', 'texture2', etc.)

            sim: new Simulator(),
            selectedFxTypes: [], // CHANGED: Now an array for multi-selection
            clipboard: null, // Stores { type: 'emitter'|'info', data: Object }

            // Helper function to find interpolation value for a given time
            // Used internally by syncKeyframe
            getInterpValue: function (keys, time) {
                if (keys.length === 0) return 0;
                if (keys.length === 1) return keys[0].val;

                // Find the keyframe right before or at the target time
                let i = 0;
                while (i < keys.length - 1 && keys[i + 1].time <= time) i++;

                const k1 = keys[i];
                const k2 = keys[i + 1] || k1;

                if (!k2 || Math.abs(k2.time - k1.time) < 1e-6) return k1.val; // Found exact key or division by zero

                // Linear Interpolation
                const t = (time - k1.time) / (k2.time - k1.time);
                return k1.val + (k2.val - k1.val) * t;
            },

            // NEW: Synchronization logic
            syncKeyframe: function (infoData, targetTime, targetKeyName, mode) {
                const requiredTimes = new Set();
                const floatTolerance = 1e-6;

                // 1. Collect all times from all interpolatable properties
                for (const keyName in infoData) {
                    if (infoData.hasOwnProperty(keyName)) {
                        const prop = infoData[keyName];
                        if (prop && typeof prop === 'object' && prop.keys) {
                            prop.keys.forEach(function (k) { requiredTimes.add(k.time); });
                        }
                    }
                }

                // 2. Adjust required times based on mode
                if (mode !== 'DELETE' && targetTime !== undefined) {
                    requiredTimes.add(targetTime);
                } else if (mode === 'DELETE' && targetTime !== undefined) {
                    requiredTimes.forEach(function (time) {
                        if (Math.abs(time - targetTime) < floatTolerance) {
                            requiredTimes.delete(time);
                        }
                    });
                }

                const sortedRequiredTimes = Array.from(requiredTimes).sort(function (a, b) { return a - b; });

                // 3. Process each interpolatable property to ensure keyframes exist
                for (const keyName in infoData) {
                    if (infoData.hasOwnProperty(keyName)) {
                        const prop = infoData[keyName];
                        if (prop && typeof prop === 'object' && prop.keys) {

                            let currentKeys = prop.keys;
                            let newKeys = [];

                            // 4. For each required time, create or update a key.
                            sortedRequiredTimes.forEach(function (time) {
                                let existingKey = currentKeys.find(function (k) { return Math.abs(k.time - time) < floatTolerance; });

                                if (existingKey) {
                                    // Key exists: Use existing time and value
                                    newKeys.push({ time: existingKey.time, val: existingKey.val });
                                } else {
                                    // Key missing: Interpolate the value from the current keys
                                    const interpolatedValue = this.getInterpValue(currentKeys, time);

                                    newKeys.push({
                                        time: time,
                                        val: interpolatedValue,
                                        // Ensure new keys have sane default values if interpolation fails
                                    });
                                }
                            }.bind(this));

                            // 5. Update the property's keys with the synchronized list
                            prop.keys = newKeys.sort(function (a, b) { return a.time - b.time; });
                        }
                    }
                }
            },

            // New method to render the tile UI (Modified for Multi-Select)
            renderFxInfoModal: function (targetId) {
                this.contextEmitterId = targetId || this.selectedId
                const container = document.getElementById('fx_type_tile_container');
                const confirmBtn = document.getElementById('confirm_add_fx_btn');
                container.innerHTML = '';
                this.selectedFxTypes = []; // Reset selection array
                confirmBtn.disabled = true;



                FX_INFO_TYPES_MAP.forEach(function (item) {
                    const originalName = item.type.replace('FX_INFO_', '').replace('_DATA', '');
                    const tile = document.createElement('div');
                    tile.className = 'tile card h-32 bg-base-300 shadow-md hover:bg-primary/20 transition-all cursor-pointer border border-base-content/10';
                    tile.dataset.fxType = item.type; // Store type for selection logic

                    // Check if this type is already present in the emitter (disable if so)
                    const found = app.findItem(app.contextEmitterId);
                    const isExisting = found && found.type === 'emitter' && found.item.infos.some(function (i) { return i.type === item.type; });

                    if (isExisting) {
                        tile.classList.add('opacity-40', 'pointer-events-none', 'cursor-not-allowed', 'border-error/50');
                        tile.title = "Block already exists in this emitter.";
                    }
                    tile.innerHTML = `
                        <div class="card-body p-3 flex-row items-center gap-4">
                            <i class="fas ${item.icon} text-3xl w-8 text-primary/80 flex-shrink-0"></i>
                            <div class="flex-1 min-w-0">
                                <h4 class="font-bold text-sm truncate">${item.name}</h4>
                                <p class="text-xs opacity-80">${item.desc}</p>
                                <p class="text-xs opacity-50 mt-1 italic">${originalName}</p>
                            </div>
                        </div>
                    `;
                    if (!isExisting) {
                        tile.onclick = function () {
                            const type = tile.dataset.fxType;
                            const index = this.selectedFxTypes.indexOf(type);

                            if (index === -1) {
                                // Select
                                this.selectedFxTypes.push(type);
                                tile.classList.add('selected-tile');
                            } else {
                                // Deselect
                                this.selectedFxTypes.splice(index, 1);
                                tile.classList.remove('selected-tile');
                            }

                            // Update button state based on selection array length
                            confirmBtn.disabled = this.selectedFxTypes.length === 0;
                        }.bind(this); // Bind context for onclick
                    }


                    container.appendChild(tile);
                }.bind(this)); // Bind context for forEach
            },

            init: function () {
                // Remove the old setTimeout, run immediate.
                // The new window.onload wrapper should handle DOM/THREE readiness.
                this.sim.init();

                // Initialize the modal tile content
                this.renderFxInfoModal();

                const save = localStorage.getItem('gta_fxp_autosave');

                try {
                    if (save) {
                        this.data = JSON.parse(save);
                        this.renderTree();
                        customAlert('Autosave loaded', 'info');
                    } else {
                        this.newProject();
                    }
                } catch (e) {
                    console.error("Error loading or parsing autosave:", e);
                    customAlert('Autosave corrupted. Starting new project.', 'error');
                    this.newProject();
                }
            },

            // Utility to check if the selection is a descendant of the given item
            isDescendantSelected: function (item) {
                if (!this.selectedId) return false;
                const found = this.findItem(this.selectedId);
                if (!found) return false;

                // If the selected item IS the root of the hierarchy (system/emitter)
                if (item._id === this.selectedId) return true;

                // Check if the selected item is a child info block
                if (item.infos && item.infos.some(function (info) { return info._id === this.selectedId; }.bind(this))) return true;

                // Check if the selected item is a child emitter or its info block
                if (item.emitters) {
                    return item.emitters.some(function (em) { return em._id === this.selectedId || em.infos.some(function (info) { return info._id === this.selectedId; }.bind(this)); }.bind(this));
                }

                return false;
            },

            newProject: function () {
                this.data = { systems: [] };
                this.renderTree();
                this.select(null);

                // FIX: Clear the file input value so selecting the same file triggers 'onchange'
                const fileInput = document.getElementById('file-upload');
                if (fileInput) {
                    fileInput.value = '';
                }
            },

            importData: function (text, filename) {
                try {
                    const parsedData = FXParser.parse(text);

                    if (!parsedData.systems || parsedData.systems.length === 0) {
                        customAlert('No valid FX systems found in file.', 'error');
                        return;
                    }

                    // Logic: Is this a merge or a new project?
                    // If we already have systems, ask the user.
                    if (this.data && this.data.systems && this.data.systems.length > 0) {

                        customConfirm(
                            `You are loading "${filename}".\nDo you want to APPEND these systems to your current project?\n(Cancel will replace the current project)`,
                            "Import Options"
                        ).then(function (shouldAppend) {
                            if (shouldAppend) {
                                // APPEND LOGIC
                                // We regenerate IDs for imported systems to prevent collisions
                                parsedData.systems.forEach(function (sys) {
                                    sys._id = uuid(); // New System ID
                                    if (sys.emitters) {
                                        sys.emitters.forEach(function (em) {
                                            em._id = uuid(); // New Emitter ID
                                            if (em.infos) {
                                                em.infos.forEach(function (info) {
                                                    info._id = uuid(); // New Info ID
                                                });
                                            }
                                        });
                                    }
                                    // Add to current data
                                    app.data.systems.push(sys);
                                });

                                app.renderTree();
                                customAlert(`Appended ${parsedData.systems.length} system(s).`, 'success');

                            } else {
                                // REPLACE LOGIC
                                app.data = parsedData;
                                app.newProjectSetup(); // Helper to reset view
                                customAlert('Project Loaded (Replaced)', 'success');
                            }
                        });

                    } else {
                        // No existing data, just load it
                        this.data = parsedData;
                        this.newProjectSetup();
                        customAlert('Project Loaded', 'success');
                    }

                } catch (e) {
                    console.error(e);
                    customAlert('Load Failed: ' + e.message, 'error');
                }
            },

            // Helper to reset view after a full load
            newProjectSetup: function () {
                this.renderTree();
                // Select the first system if available
                if (this.data.systems.length > 0) {
                    this.select(this.data.systems[0]._id);
                } else {
                    this.select(null);
                }
            },

            findItem: function (id) {
                // FIX: Guard against app.data being null during initialization
                if (!this.data) return null;

                for (let sys of this.data.systems) {
                    if (sys._id === id) return { item: sys, parent: this.data.systems, type: 'system', root: sys };
                    for (let em of sys.emitters) {
                        if (em._id === id) return { item: em, parent: sys.emitters, type: 'emitter', root: sys };
                        for (let inf of em.infos) {
                            if (inf._id === id) return { item: inf, parent: em.infos, type: 'info', root: sys };
                        }
                    }
                }
                return null;
            },

            // Debounced Select Function
            select: function (id) {
                this.selectedId = id;

                if (selectTimeout) clearTimeout(selectTimeout);

                selectTimeout = setTimeout(function () {
                    this.renderTree();

                    const found = id ? this.findItem(id) : null;
                    if (!found) {
                        this.sim.setActiveSystem(null);
                        this.renderProperties(null, null);
                        selectTimeout = null;
                        return;
                    }

                    this.sim.setActiveSystem(found.root);
                    this.renderProperties(found.item, found.type);
                    selectTimeout = null;
                }.bind(this), 50);
            },

            renderTree: function () {
                const root = document.getElementById('tree-root');
                root.innerHTML = '';

                if (!this.data || !this.data.systems) return;

                this.data.systems.forEach(function (sys) {
                    const isSysSelected = this.isDescendantSelected(sys);

                    const sysDiv = document.createElement('div');
                    // PASSED 'system' AND sys object
                    const sysRow = this.createRow(sys.name || 'System', 'folder', sys._id, this.selectedId === sys._id, !!sys.emitters.length, isSysSelected, 'system', sys);
                    sysDiv.appendChild(sysRow.container);

                    const sysChildrenContainer = document.createElement('div');
                    sysChildrenContainer.className = `tree-children ${isSysSelected ? '' : 'collapsed'}`;
                    sysChildrenContainer.id = `children-${sys._id}`;

                    if (sysRow.iconWrapper) {
                        sysRow.iconWrapper.onclick = function (e) {
                            e.stopPropagation();
                            sysChildrenContainer.classList.toggle('collapsed');
                            sysRow.iconWrapper.querySelector('i').className = sysChildrenContainer.classList.contains('collapsed') ? 'fas fa-chevron-right' : 'fas fa-chevron-down';
                        };
                    }

                    const sysChildren = document.createElement('div');
                    sysChildren.className = 'pl-1';

                    if (sys.emitters) {
                        sys.emitters.forEach(function (em) {
                            const isEmSelected = this.isDescendantSelected(em);
                            // PASSED 'emitter' AND em object
                            const emRow = this.createRow(em.name || 'Emitter', 'cubes', em._id, this.selectedId === em._id, !!em.infos.length, isEmSelected, 'emitter', em);
                            sysChildren.appendChild(emRow.container);

                            const emChildrenContainer = document.createElement('div');
                            emChildrenContainer.className = `tree-children ${isEmSelected ? '' : 'collapsed'}`;
                            emChildrenContainer.id = `children-${em._id}`;

                            if (emRow.iconWrapper) {
                                emRow.iconWrapper.onclick = function (e) {
                                    e.stopPropagation();
                                    emChildrenContainer.classList.toggle('collapsed');
                                    emRow.iconWrapper.querySelector('i').className = emChildrenContainer.classList.contains('collapsed') ? 'fas fa-chevron-right' : 'fas fa-chevron-down';
                                };
                            }

                            const emChildren = document.createElement('div');
                            emChildren.className = 'pl-1';

                            if (em.infos) {
                                em.infos.forEach(function (inf) {
                                    // Passed 'info' (no add button generated for this type)
                                    const infRow = this.createRow(inf.type.replace('FX_INFO_', ''), 'bolt', inf._id, this.selectedId === inf._id, false, false, 'info', inf);
                                    emChildren.appendChild(infRow.container);
                                }.bind(this));
                            }
                            emChildrenContainer.appendChild(emChildren);
                            sysChildren.appendChild(emChildrenContainer);
                        }.bind(this));
                    }
                    sysChildrenContainer.appendChild(sysChildren);
                    sysDiv.appendChild(sysChildrenContainer);
                    root.appendChild(sysDiv);
                }.bind(this));
            },

            createRow: function (text, icon, id, isSelected, hasChildren, isExpanded, type, item) {
                const container = document.createElement('div');

                const div = document.createElement('div');
                div.className = `tree-item ${isSelected ? 'selected' : ''}`;
                div.dataset.id = id;

                // 1. LEFT SIDE: Content (Icon + Text)
                // Flex-1 ensures it pushes the actions to the far right
                const content = document.createElement('div');
                content.className = "flex items-center flex-1 overflow-hidden mr-2";

                let iconWrapper = null;
                if (hasChildren) {
                    iconWrapper = document.createElement('span');
                    iconWrapper.className = `w-4 mr-1 text-center opacity-70 flex-shrink-0 ${isSelected ? 'text-white' : 'text-primary/70'}`;
                    iconWrapper.innerHTML = `<i class="fas ${isExpanded ? 'fa-chevron-down' : 'fa-chevron-right'} text-xs"></i>`;
                    content.appendChild(iconWrapper);
                } else {
                    content.innerHTML = `<span class="w-4 mr-1 flex-shrink-0"></span>`;
                }

                content.innerHTML += `<i class="fas fa-${icon} w-4 mr-2 opacity-70 flex-shrink-0"></i> <span class="truncate">${text}</span>`;
                div.appendChild(content);

                // --- RIGHT SIDE: ACTIONS ---
                const actions = document.createElement('div');
                actions.className = "flex items-center flex-shrink-0";

                // 1. PASTE BUTTON (Condition: Clipboard has data COMPATIBLE with this row)
                let canPaste = false;
                if (app.clipboard) {
                    if (type === 'system' && app.clipboard.type === 'emitter') canPaste = true;
                    if (type === 'emitter' && app.clipboard.type === 'info') canPaste = true;
                }

                if (canPaste) {
                    const pasteBtn = document.createElement('button');
                    pasteBtn.className = "paste-btn";
                    pasteBtn.innerHTML = '<i class="fas fa-paste"></i>';
                    pasteBtn.title = "Paste here";
                    pasteBtn.addEventListener('click', function (e) {
                        e.stopPropagation();
                        app.pasteItem(id);
                    });
                    actions.appendChild(pasteBtn);
                }

                // 2. COPY BUTTON (Visible on Emitters and Infos)
                if (type === 'emitter' || type === 'info') {
                    const copyBtn = document.createElement('button');
                    copyBtn.className = "copy-btn";
                    copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
                    copyBtn.title = "Copy";
                    copyBtn.addEventListener('click', function (e) {
                        e.stopPropagation();
                        app.copyItem(id);
                    });
                    actions.appendChild(copyBtn);
                }

                // 3. ADD BUTTON (Only if Selected)
                if (true) {
                    if (type === 'system') {
                        const addBtn = document.createElement('button');
                        addBtn.className = "add-btn";
                        addBtn.innerHTML = '<i class="fas fa-plus"></i>';
                        addBtn.title = "Add Emitter";
                        addBtn.addEventListener('click', function (e) {
                            e.stopPropagation();
                            app.addEmitter(item);
                        });
                        actions.appendChild(addBtn);
                    }
                    else if (type === 'emitter') {
                        const addBtn = document.createElement('button');
                        addBtn.className = "add-btn";
                        addBtn.innerHTML = '<i class="fas fa-plus"></i>';
                        addBtn.title = "Add FX Info Block";
                        addBtn.addEventListener('click', function (e) {
                            e.stopPropagation();
                            // Pass ID to modal
                            app.renderFxInfoModal(item._id);
                            document.getElementById('add_fx_modal').showModal();
                        });
                        actions.appendChild(addBtn);
                    }
                }

                // --- MOVE BUTTONS (Only for Info items) ---
                if (type === 'emitter') {
                    // Move Up
                    const upBtn = document.createElement('button');
                    // Reuse copy-btn class for consistent sizing/fading
                    upBtn.className = "copy-btn text-base-content/50 hover:text-white";
                    upBtn.innerHTML = '<i class="fas fa-chevron-up text-[10px]"></i>';
                    upBtn.title = "Move Up";
                    upBtn.onclick = function (e) {
                        e.stopPropagation();
                        app.moveItem(id, -1);
                    };
                    actions.appendChild(upBtn);

                    // Move Down
                    const downBtn = document.createElement('button');
                    downBtn.className = "copy-btn text-base-content/50 hover:text-white";
                    downBtn.innerHTML = '<i class="fas fa-chevron-down text-[10px]"></i>';
                    downBtn.title = "Move Down";
                    downBtn.onclick = function (e) {
                        e.stopPropagation();
                        app.moveItem(id, 1);
                    };
                    actions.appendChild(downBtn);
                }

                // 4. DELETE BUTTON
                const delBtn = document.createElement('button');
                delBtn.className = "delete-btn";
                delBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                delBtn.title = "Delete Item";
                delBtn.addEventListener('click', function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    app.deleteItem(id);
                });
                actions.appendChild(delBtn);

                div.appendChild(actions);

                // Row Click
                div.addEventListener('click', function (e) {
                    e.stopPropagation();
                    app.select(id);
                });

                container.appendChild(div);
                return { container, iconWrapper };
            },

            moveItem: function (id, direction) {
                const found = this.findItem(id);
                // Ensure we found the item and it is an Info block (inside a parent array)
                if (!found || found.type !== 'emitter' || !Array.isArray(found.parent)) return;

                const list = found.parent;
                const idx = list.findIndex(function (i) { return i._id === id; });
                if (idx === -1) return;

                // Calculate swap target index
                const targetIdx = idx + direction;

                // Bounds Check
                if (targetIdx >= 0 && targetIdx < list.length) {
                    // Swap elements using a temp variable
                    const temp = list[idx];
                    list[idx] = list[targetIdx];
                    list[targetIdx] = temp;

                    this.save();
                    this.renderTree();
                }
            },

            // DELETION BY SEARCH AND DESTROY 
            deleteItem: function (id) {
                let deleted = false;
                const wasSelected = this.selectedId === id;

                // 1. Check Systems
                const sysIdx = this.data.systems.findIndex(function (s) { return s._id === id; });
                if (sysIdx > -1) {
                    const delSys = this.data.systems[sysIdx];
                    this.data.systems.splice(sysIdx, 1);
                    if (this.sim.activeSystem && this.sim.activeSystem._id === delSys._id) { this.sim.setActiveSystem(null); }
                    deleted = true;
                }

                // 2. Check Emitters
                if (!deleted) {
                    for (let s of this.data.systems) {
                        const emIdx = s.emitters.findIndex(function (e) { return e._id === id; });
                        if (emIdx > -1) {
                            s.emitters.splice(emIdx, 1);
                            if (this.sim.activeSystem && this.sim.activeSystem._id === s._id) { this.sim.setActiveSystem(s); }
                            deleted = true;
                            break;
                        }
                    }
                }

                // 3. Check Info
                if (!deleted) {
                    for (let s of this.data.systems) {
                        for (let e of s.emitters) {
                            const infoIdx = e.infos.findIndex(function (i) { return i._id === id; });
                            if (infoIdx > -1) {
                                e.infos.splice(infoIdx, 1);
                                deleted = true;
                                break;
                            }
                        }
                        if (deleted) break;
                    }
                }

                if (deleted) {
                    if (wasSelected) {
                        this.select(null);
                    } else {
                        this.select(this.selectedId);
                    }

                    this.save();
                    customAlert("Item Deleted", "success");
                } else {
                    console.error("Item ID not found:", id);
                }
            },

            deleteSelected: function () {
                if (this.selectedId) {
                    customConfirm('Delete this item? This action cannot be undone.')
                        .then(function (confirmed) {
                            if (confirmed) {
                                this.deleteItem(this.selectedId);
                            }
                        }.bind(this));
                }
            },
            addBlendSelect: function (parent, label, propKey, target, root) {
                const d = document.createElement('div');
                d.className = 'form-control mb-2';
                d.innerHTML = `<label class="label py-0 text-xs font-bold opacity-60">${label}</label>`;
                const sel = document.createElement('select');
                sel.className = 'select select-sm select-bordered w-full';

                // FIXED: Mapped based on GTA SA 'effects.fxp' usage
                const options = [
                    { val: 1, text: '1: ONE (Additive)' },
                    { val: 2, text: '2: ZERO' },
                    { val: 3, text: '3: SRCCOLOR' },
                    { val: 4, text: '4: SRCALPHA (Transp)' },
                    { val: 5, text: '5: INVSRCALPHA' },
                    { val: 6, text: '6: INVSRCCOLOR' }
                ];

                options.forEach(function (opt) {
                    const option = document.createElement('option');
                    option.value = opt.val;
                    option.textContent = opt.text;
                    if (target[propKey] === opt.val) option.selected = true;
                    sel.appendChild(option);
                });

                sel.onchange = function (e) {
                    target[propKey] = parseInt(e.target.value);
                    this.save();
                    // FIX: The root object is needed here, but the function's 'this' scope is 'app'.
                    // We use the 'root' parameter passed from renderProperties.
                    this.sim.setActiveSystem(root);
                }.bind(this);

                d.appendChild(sel);
                parent.appendChild(d);
            },
            renderProperties: function (target, type) {
                const pDiv = document.getElementById('property-editor');
                const pAct = document.getElementById('prop-actions');
                const pTitle = document.getElementById('prop-title');
                pDiv.innerHTML = ''; pAct.innerHTML = '';

                if (!target) {
                    pTitle.innerText = 'Properties';
                    return;
                }

                pTitle.innerText = type.toUpperCase();
                const self = this;
                const found = this.findItem(target._id); // Re-find the item to get the latest root context

                // DELETE BUTTON IN HEADER 
                const delBtn = document.createElement('button');
                delBtn.className = 'btn btn-xs btn-error btn-outline ml-2';
                delBtn.innerHTML = '<i class="fas fa-trash"></i> Delete Selected';
                delBtn.onclick = function () { self.deleteSelected(); };
                pAct.appendChild(delBtn);

                if (type === 'system') {
                    this.addInput(pDiv, 'Name', target.name, function (v) { target.name = v; });
                    this.addInput(pDiv, 'Length', target.length, function (v) { target.length = parseFloat(v); }, 'number');

                    this.addInput(pDiv, 'Play Mode', target.playMode, function (v) { target.playMode = parseInt(v); }, 'number');
                    this.addInput(pDiv, 'Loop Int', target.loopInterval, function (v) { target.loopInterval = parseFloat(v); }, 'number');
                    this.addInput(pDiv, 'Culldist', target.culldistance, function (v) { target = parseFloat(v); }, 'number');
                    this.addInput(pDiv, 'Omit textures', target.omittextures, function (v) { target = parseInt(v); }, 'number');

                    const btn = document.createElement('button');
                    btn.className = 'btn btn-xs btn-success';
                    btn.innerText = '+ Emitter';
                    btn.onclick = function () { self.addEmitter(target); };
                    pAct.appendChild(btn);
                }
                else if (type === 'emitter') {
                    pTitle.innerText = `EMITTER: ${target.name}`;

                    // 1. Name and Texture
                    this.addInput(pDiv, 'Name', target.name, function (v) { target.name = v; });
                    // Ensure Texture change triggers system update to load new texture
                    // 2. Texture Slots (1-4) [FIX: Added inputs for all slots]
                   this.addTextureInput(pDiv, 'Texture 1 (Primary)', target, 'texture');
                    this.addTextureInput(pDiv, 'Texture 2', target, 'texture2');
                    this.addTextureInput(pDiv, 'Texture 3', target, 'texture3');
                    this.addTextureInput(pDiv, 'Texture 4', target, 'texture4');
                    this.addInput(pDiv, 'Lod Start', target.lodstart, function (v) { target = parseFloat(v); }, 'number');
                    this.addInput(pDiv, 'Lod End', target.lodend, function (v) { target = parseFloat(v); }, 'number');

                    // 2. AlphaOn (Toggle)
                    const alphaToggle = document.createElement('div');
                    alphaToggle.className = 'form-control mb-2 flex items-center gap-3';
                    alphaToggle.innerHTML = `
            <label class="label cursor-pointer py-0 text-xs font-bold opacity-60">ALPHA ON (1/0)</label>
            <input type="checkbox" class="toggle toggle-sm toggle-accent" ${target.alphaOn == 1 ? 'checked' : ''}>
        `;
                    alphaToggle.querySelector('input').onchange = function (e) {
                        target.alphaOn = e.target.checked ? 1 : 0;
                        self.save();
                        self.sim.setActiveSystem(found.root); // Reapply material settings
                    };
                    pDiv.appendChild(alphaToggle);

                    // 3. Blend IDs (Dropdowns for common modes)
                    // Correct call to the method attached to 'this'
                    this.addBlendSelect(pDiv, 'SRC BLEND ID', 'srcBlend', target, found.root);
                    this.addBlendSelect(pDiv, 'DST BLEND ID', 'dstBlend', target, found.root);


                    // --- CRUD Actions ---
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-xs btn-info';
                    btn.innerText = '+ FX Info';
                    // Before showing modal, ensure tiles are reset
                    btn.onclick = function () { app.renderFxInfoModal(); document.getElementById('add_fx_modal').showModal(); };
                    pAct.appendChild(btn);
                }
                else if (type === 'info') {
                    // Separate Data into Statics (Single values) and Timelines (Keys)
                    const staticProps = {};
                    let hasTimelines = false;

                    for (const key in target.data) {
                        const val = target.data[key];
                        if (val && typeof val === 'object' && val.keys) {
                            hasTimelines = true;
                        } else {
                            staticProps[key] = val;
                        }
                    }

                    // 1. Render Static Properties first (TIMEMODEPRT, etc)
                    if (Object.keys(staticProps).length > 0) {
                        const staticGroup = document.createElement('div');
                        staticGroup.className = "grid grid-cols-2 gap-2 mb-4 p-2 bg-base-200 rounded";
                        for (const key in staticProps) {
                            // Create a mini wrapper for label + input
                            const wrap = document.createElement('div');
                            this.addInput(wrap, key, staticProps[key], (v) => {
                                // Logic for float vs int based on key name
                                if (key === 'TIMEMODEPRT') target.data[key] = parseInt(v);
                                else target.data[key] = parseFloat(v);
                            }, 'number');
                            staticGroup.appendChild(wrap);
                        }
                        pDiv.appendChild(staticGroup);
                    }

                    // 2. Render Unified Timeline Table
                    if (hasTimelines) {
                        this.renderUnifiedTable(pDiv, target.data);
                    }
                }
            },

            openTextureBrowser: function (targetObj, targetProp) {
                this.texTargetObj = targetObj;
                this.texTargetProp = targetProp;

                const grid = document.getElementById('texture_browser_grid');
                grid.innerHTML = '';

                const textureNames = Object.keys(this.sim.textures);

                if (textureNames.length === 0) {
                    grid.innerHTML = `<div class="col-span-full text-center opacity-50 italic py-10">No textures loaded. Use "Load Textures" in the File menu first.</div>`;
                }

                textureNames.forEach(function (name) {
                    const tex = this.sim.textures[name];

                    const tile = document.createElement('div');
                    tile.className = 'texture-tile';
                    tile.title = name;

                    // Image Preview
                    const img = document.createElement('img');
                    // Check if it's a loaded texture with an image source
                    if (tex.image && tex.image.src) {
                        img.src = tex.image.src;
                    } else {
                        // Fallback for procedural/canvas textures
                        img.src = '';
                        img.alt = 'No Preview';
                    }

                    // Name Label
                    const label = document.createElement('span');
                    label.innerText = name;

                    tile.appendChild(img);
                    tile.appendChild(label);

                    // Click Handler
                    tile.onclick = function () {
                        // 1. Update Data
                        this.texTargetObj[this.texTargetProp] = name;

                        // 2. Save & Update Simulation
                        this.save();
                        // Find root system to refresh the material
                        const found = this.findItem(this.texTargetObj._id);
                        if (found) this.sim.setActiveSystem(found.root);

                        // 3. Refresh Property Editor UI (to show new text in input)
                        this.renderProperties(this.texTargetObj, 'emitter');

                        // 4. Close Modal
                        document.getElementById('texture_browser_modal').close();
                    }.bind(this);

                    grid.appendChild(tile);
                }.bind(this));

                document.getElementById('texture_browser_modal').showModal();
            },

            // --- NEW: Helper for Property Editor ---
            addTextureInput: function (parent, label, obj, prop) {
                const d = document.createElement('div');
                d.className = 'form-control mb-2';
                d.innerHTML = `<label class="label py-0 text-xs font-bold opacity-60">${label}</label>`;

                const group = document.createElement('div');
                group.className = 'join w-full';

                // 1. Text Input (Editable)
                const inp = document.createElement('input');
                inp.className = 'input input-sm input-bordered join-item w-full';
                inp.type = 'text';
                inp.value = obj[prop] || 'null';
                inp.onchange = function (e) {
                    obj[prop] = e.target.value;
                    this.save();
                    const found = this.findItem(obj._id);
                    if (found) this.sim.setActiveSystem(found.root);
                }.bind(this);

                // 2. Browser Button
                const btn = document.createElement('button');
                btn.className = 'btn btn-sm btn-neutral join-item';
                btn.innerHTML = '<i class="fas fa-folder-open"></i>'; // Folder icon
                btn.title = "Select Loaded Texture";
                btn.onclick = function () {
                    this.openTextureBrowser(obj, prop);
                }.bind(this);

                group.appendChild(inp);
                group.appendChild(btn);
                d.appendChild(group);
                parent.appendChild(d);
            },

            // --- COPY / PASTE LOGIC ---
            copyItem: function (id) {
                const found = this.findItem(id);
                if (!found) return;

                // Deep clone the data to prevent reference issues
                // We strip the _id immediately so we don't accidentally reuse it later
                const dataClone = JSON.parse(JSON.stringify(found.item));

                this.clipboard = {
                    type: found.type, // 'emitter' or 'info'
                    data: dataClone
                };

                customAlert(`Copied ${found.type}: ${found.item.name || found.item.type}`, "info");
                this.renderTree(); // Re-render to show Paste buttons
            },

            pasteItem: function (targetId) {
                if (!this.clipboard) return;

                const found = this.findItem(targetId);
                if (!found) return;

                const pasteType = this.clipboard.type;
                const targetType = found.type;

                // 1. Paste Emitter -> Into System
                if (pasteType === 'emitter' && targetType === 'system') {
                    const newEm = JSON.parse(JSON.stringify(this.clipboard.data));

                    // REGENERATE IDs (Critical!)
                    newEm._id = uuid();
                    newEm.infos.forEach(i => i._id = uuid()); // Regenerate IDs for children

                    // Append
                    found.item.emitters.push(newEm);
                    this.select(newEm._id); // Select the new item
                }
                // 2. Paste Info -> Into Emitter
                else if (pasteType === 'info' && targetType === 'emitter') {
                    const newInfo = JSON.parse(JSON.stringify(this.clipboard.data));

                    // Check duplicates (Optional: GTA usually only allows one block of each type)
                    // If strictly enforcing 1 type per emitter, enable this check:
                    /*
                    if (found.item.infos.some(i => i.type === newInfo.type)) {
                        customAlert("This block type already exists here.", "warning");
                        return;
                    }
                    */

                    newInfo._id = uuid(); // Regenerate ID
                    found.item.infos.push(newInfo);
                    this.select(newInfo._id);
                }

                this.save();
                // Render tree will happen automatically by this.select, but purely for safety:
                this.renderTree();
                customAlert("Pasted successfully", "success");
            },

            updateGroundHeight: function (val) {
                const h = parseFloat(val);
                this.sim.groundHeight = h;

                // Update Button Text
                const display = document.getElementById('ground-val');
                if (display) display.innerText = h.toFixed(1);

                // Move the Visual Grid
                if (this.sim.gridHelper) {
                    this.sim.gridHelper.position.y = h;
                }
            },

            // --- NEW: Handle Wind Sliders ---
            updateWind: function (axis, val) {
                const v = parseFloat(val);

                if (axis === 'x') this.sim.globalWind.x = v;
                if (axis === 'z') this.sim.globalWind.z = v; // Z is depth in Three.js (Y is up)

                // Update UI Labels
                document.getElementById(`wind-${axis}-val`).innerText = v.toFixed(1);

                const isWindy = Math.abs(this.sim.globalWind.x) > 0.1 || Math.abs(this.sim.globalWind.z) > 0.1;
                const btnVal = document.getElementById('wind-val');
                if (btnVal) btnVal.innerText = isWindy ? "ON" : "OFF";

                // Optional: Update button color
                const btn = document.getElementById('wind-btn');
                if (btn) {
                    if (isWindy) {
                        btn.classList.remove('btn-neutral');
                        btn.classList.add('btn-info');
                    } else {
                        btn.classList.remove('btn-info');
                        btn.classList.add('btn-neutral');
                    }
                }
            },

            addInput: function (parent, label, val, cb, type = 'text') {
                const d = document.createElement('div');
                d.className = 'form-control mb-2';
                d.innerHTML = `<label class="label py-0 text-xs font-bold opacity-60">${label}</label>`;
                const inp = document.createElement('input');
                inp.className = 'input input-sm input-bordered';
                inp.type = type; inp.value = val;
                inp.step = '0.1';
                inp.onchange = function (e) { cb(e.target.value); this.save(); this.renderTree(); }.bind(this);
                d.appendChild(inp);
                parent.appendChild(d);
            },

            // NEW: Scans all properties in an Info block and forces them to share the same time keys
            unifyInfoData: function (infoData) {
                const uniqueTimes = new Set();
                const floatTolerance = 1e-4;
                const propNames = [];

                // 1. Collect all unique times from all properties
                for (const key in infoData) {
                    if (infoData.hasOwnProperty(key)) {
                        const prop = infoData[key];
                        if (prop && typeof prop === 'object' && prop.keys) {
                            propNames.push(key);
                            prop.keys.forEach(k => {
                                // Round to avoid float precision duplicates (e.g. 0.1 vs 0.1000001)
                                uniqueTimes.add(Math.round(k.time * 10000) / 10000);
                            });
                        }
                    }
                }

                if (propNames.length === 0) return null; // No timelines here

                // 2. Sort times
                const sortedTimes = Array.from(uniqueTimes).sort((a, b) => a - b);

                // Ensure t=0 exists
                if (sortedTimes.length === 0 || sortedTimes[0] > 0) {
                    sortedTimes.unshift(0);
                }

                // 3. Rebuild every property to have exactly these keys
                propNames.forEach(name => {
                    const prop = infoData[name];
                    const oldKeys = prop.keys;
                    const newKeys = [];

                    sortedTimes.forEach(time => {
                        // Try to find existing key very close to this time
                        const existing = oldKeys.find(k => Math.abs(k.time - time) < floatTolerance);

                        if (existing) {
                            newKeys.push({ time: time, val: existing.val });
                        } else {
                            // Interpolate if missing
                            const val = this.getInterpValue(oldKeys, time);
                            newKeys.push({ time: time, val: val });
                        }
                    });

                    prop.keys = newKeys;
                });

                return sortedTimes; // Return the master time list
            },

            // NEW: Renders the spreadsheet-like UI
            renderUnifiedTable: function (parent, infoData) {
                // 1. Sync data first
                const times = this.unifyInfoData(infoData);
                if (!times) return; // Should not happen if we checked type

                // Container for the scrollable table
                const container = document.createElement('div');
                container.className = "overflow-x-auto bg-base-200 rounded border border-base-content/10 mb-4 shadow-inner custom-scroll";

                const table = document.createElement('table');
                table.className = "table table-xs table-pin-rows";

                // --- HEADER (Time Values) ---
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');

                // Corner Cell
                const corner = document.createElement('th');
                corner.className = "bg-base-300 z-10 w-24 min-w-[6rem]";
                corner.innerText = "Property";
                headerRow.appendChild(corner);

                // Time Columns
                times.forEach((time, tIdx) => {
                    const th = document.createElement('th');
                    th.className = "text-center min-w-[7rem] p-1 bg-base-300 align-middle"; // Increased width slightly

                    // NEW: Flex Row layout (items-center) instead of Column
                    const div = document.createElement('div');
                    div.className = "flex items-center justify-center gap-1";

                    // 1. Delete Button (Left) - Only if not first key
                    if (tIdx > 0) {
                        const delBtn = document.createElement('button');
                        delBtn.className = "btn btn-xs btn-square btn-ghost text-error opacity-50 hover:opacity-100";
                        delBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                        delBtn.title = "Delete Key";
                        delBtn.onclick = () => {
                            for (const key in infoData) {
                                if (infoData[key].keys) infoData[key].keys.splice(tIdx, 1);
                            }
                            this.save();
                            this.renderProperties(this.findItem(this.selectedId).item, 'info');
                        };
                        div.appendChild(delBtn);
                    } else {
                        // Spacer to keep alignment for the first column
                        const spacer = document.createElement('div');
                        spacer.className = "w-6 h-6";
                        div.appendChild(spacer);
                    }

                    // 2. Time Input (Center)
                    const tInput = document.createElement('input');
                    tInput.type = "number";
                    tInput.step = "0.05";
                    // Fixed width (w-14) so it fits nicely between buttons
                    tInput.className = "input input-xs input-ghost text-center font-bold text-accent w-14 p-0 h-6";
                    tInput.value = time;
                    tInput.onchange = (e) => {
                        const newVal = parseFloat(e.target.value);
                        for (const key in infoData) {
                            if (infoData[key].keys) infoData[key].keys[tIdx].time = newVal;
                        }
                        this.save();
                        this.renderProperties(this.findItem(this.selectedId).item, 'info');
                    };
                    div.appendChild(tInput);

                    // 3. Insert Button (Right)
                    const addBtn = document.createElement('button');
                    addBtn.className = "btn btn-xs btn-square btn-ghost text-success opacity-50 hover:opacity-100";
                    addBtn.title = "Insert Key After";
                    addBtn.innerHTML = '<i class="fas fa-plus "></i>';
                    addBtn.onclick = () => {
                        let nextTime = (tIdx < times.length - 1) ? times[tIdx + 1] : (time + 0.5);
                        let newTime = (time + nextTime) / 2;

                        for (const key in infoData) {
                            if (infoData[key].keys) {
                                const val = this.getInterpValue(infoData[key].keys, newTime);
                                infoData[key].keys.splice(tIdx + 1, 0, { time: newTime, val: val });
                            }
                        }
                        this.save();
                        this.renderProperties(this.findItem(this.selectedId).item, 'info');
                    };
                    div.appendChild(addBtn);

                    th.appendChild(div);
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // --- BODY (Values) ---
                const tbody = document.createElement('tbody');

                for (const key in infoData) {
                    const prop = infoData[key];
                    // Skip non-interpolated properties (like TIMEMODEPRT)
                    if (!prop || !prop.keys) continue;

                    const row = document.createElement('tr');

                    // Label Cell
                    const label = document.createElement('td');
                    label.className = "font-bold text-xs bg-base-200 sticky left-0 border-r border-base-content/10";
                    label.innerText = key;
                    row.appendChild(label);

                    // Value Cells
                    prop.keys.forEach((k, idx) => {
                        const cell = document.createElement('td');
                        cell.className = "p-1";

                        const vInput = document.createElement('input');
                        vInput.type = "number";
                        vInput.step = "0.01"; // Default step
                        if (Math.abs(k.val) > 10) vInput.step = "1"; // Adapt step for large values
                        vInput.className = "input input-xs input-bordered w-full text-right focus:input-primary";
                        vInput.value = k.val; // Don't fix decimal here to allow raw editing

                        vInput.onchange = (e) => {
                            k.val = parseFloat(e.target.value);
                            this.save();
                        };

                        cell.appendChild(vInput);
                        row.appendChild(cell);
                    });

                    tbody.appendChild(row);
                }

                table.appendChild(tbody);
                container.appendChild(table);
                parent.appendChild(container);
            },

            addSystem: function () {
                const sys = FX_DEFAULTS.system();
                sys.name = 'NewSystem';
                sys.length = 1.0;
                sys.playMode = 2;
                this.data.systems.push(sys);
                this.select(sys._id);
                this.save();
            },

            addEmitter: function (sys) {
                const em = FX_DEFAULTS.emitter();
                sys.emitters.push(em);
                this.select(em._id);
                this.save();
            },

            // UPDATED: Now adds multiple selected FX types
            confirmAddFx: function () {
                // FIX: Use traditional Array cloning instead of spread syntax to ensure ES5 compatibility
                var typesToAdd = [];
                for (var i = 0; i < this.selectedFxTypes.length; i++) {
                    typesToAdd.push(this.selectedFxTypes[i]);
                }

                if (typesToAdd.length === 0) return; // Should be disabled, but defensive check

                const found = app.findItem(this.contextEmitterId);

                // Helper to create a new interpolation block quickly (REQUIRED for most properties)
                const defaultInterp = function (val = 1, looped = 0) {
                    return { looped: looped, keys: [{ time: 0, val: val }] };
                };
                // Helper to create a single float property (e.g., for TIMEMODEPRT)
                const defaultFloat = function (val = 1) { return val; };

                if (found && found.type === 'emitter') {
                    typesToAdd.forEach(function (type) {
                        // Check again if the type was somehow added since opening the modal (highly unlikely but safe)
                        if (found.item.infos.some(function (i) { return i.type === type; })) {
                            console.warn(`FX Info type ${type} already exists. Skipping.`);
                            return;
                        }

                        const data = {};

                        // --- CORE PROPERTY INITIALIZATION ---
                        // (Same logic as before, applied per type)
                        if (type.includes('COLOUR')) { // FX_INFO_COLOUR_DATA or FX_INFO_COLOURBRIGHT_DATA
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['RED'] = defaultInterp(255);
                            data['GREEN'] = defaultInterp(255);
                            data['BLUE'] = defaultInterp(255);
                            data['ALPHA'] = defaultInterp(255);

                            if (type.includes('BRIGHT')) {
                                data['BIAS'] = defaultInterp(32.0);
                            }
                        }
                        else if (type.includes('EMDIR')) { // FX_INFO_EMDIR_DATA
                            data['DIRX'] = defaultInterp(0.0);
                            data['DIRY'] = defaultInterp(0.0);
                            data['DIRZ'] = defaultInterp(1.0);
                        }
                        else if (type.includes('EMANGLE')) { // FX_INFO_EMANGLE_DATA
                            data['MIN'] = defaultInterp(0.0);
                            data['MAX'] = defaultInterp(30.0);
                        }
                        else if (type.includes('EMROTATION')) { // FX_INFO_EMROTATION_DATA
                            data['ANGLEMIN'] = defaultInterp(0.0);
                            data['ANGLEMAX'] = defaultInterp(360.0);
                        }
                        else if (type.includes('ROTSPEED')) { // FX_INFO_ROTSPEED_DATA
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['MINCW'] = defaultInterp(0.0);
                            data['MAXCW'] = defaultInterp(180.0);
                            data['MINCCW'] = defaultInterp(0.0);
                            data['MAXCCW'] = defaultInterp(180.0);
                        }
                        else if (type.includes('_SIZE_DATA')) { // FX_INFO_SIZE_DATA (PARTICLE VISUAL DIMENSION)
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['SIZEX'] = defaultInterp(0.5);
                            data['SIZEY'] = defaultInterp(0.5);
                            data['SIZEXBIAS'] = defaultInterp(0.0);
                            data['SIZEYBIAS'] = defaultInterp(0.0);
                        }
                        else if (type.includes('EMSIZE')) { // FX_INFO_EMSIZE_DATA (EMITTER SPAWN VOLUME)
                            data['RADIUS'] = defaultInterp(0.0);
                            data['SIZEMINX'] = defaultInterp(0.0);
                            data['SIZEMAXX'] = defaultInterp(0.0);
                            data['SIZEMINY'] = defaultInterp(0.0);
                            data['SIZEMAXY'] = defaultInterp(0.0);
                            data['SIZEMINZ'] = defaultInterp(0.0);
                            data['SIZEMAXZ'] = defaultInterp(0.0);
                        }
                        else if (type.includes('EMSPEED')) { // FX_INFO_EMSPEED_DATA
                            data['SPEED'] = defaultInterp(1.0);
                            data['BIAS'] = defaultInterp(0.0);
                        }
                        else if (type.includes('EMLIFE')) { // FX_INFO_EMLIFE_DATA
                            data['LIFE'] = defaultInterp(1.0);
                            data['BIAS'] = defaultInterp(0.0);
                        }
                        else if (type.includes('EMRATE')) { // FX_INFO_EMRATE_DATA
                            data['RATE'] = defaultInterp(100.0);
                        }
                        else if (type.includes('FORCE')) { // FX_INFO_FORCE_DATA
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['FORCEX'] = defaultInterp(0.0);
                            data['FORCEY'] = defaultInterp(0.0);
                            data['FORCEZ'] = defaultInterp(-9.8);
                        }
                        else if (type.includes('FRICTION')) { // FX_INFO_FRICTION_DATA
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['FRICTION'] = defaultInterp(0.9);
                        }
                        else if (type.includes('WIND')) { // FX_INFO_WIND_DATA
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['WINDFACTOR'] = defaultInterp(5.0);
                        }
                        else if (type.includes('SPRITERECT')) { // FX_INFO_SPRITERECT_DATA (UV Coordinates)
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['TOP'] = defaultInterp(1.0);
                            data['BOTTOM'] = defaultInterp(-1.0);
                            data['LEFT'] = defaultInterp(0.5);
                            data['RIGHT'] = defaultInterp(-0.5);
                        }
                        else if (type.includes('DIR_DATA')) { // FX_INFO_DIR_DATA (Particle alignment vector)
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['X'] = defaultInterp(0.0);
                            data['Y'] = defaultInterp(0.0);
                            data['Z'] = defaultInterp(0.0);
                        }
                        else if (type.includes('FLOAT_DATA')) { // FX_INFO_FLOAT_DATA (Placeholder)
                            data['TIMEMODEPRT'] = defaultFloat(1);
                        }
                        else if (type.includes('NOISE')) { // FX_INFO_NOISE_DATA
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['NOISE'] = defaultInterp(1.0);
                        }
                        else if (type.includes('UNDERWATER')) { // FX_INFO_UNDERWATER_DATA
                            data['TIMEMODEPRT'] = defaultFloat(1);
                        }
                        else if (type.includes('SELFLIT')) { // FX_INFO_SELFLIT_DATA
                            data['TIMEMODEPRT'] = defaultFloat(1);
                        }
                        else if (type.includes('EMPOS')) { // FX_INFO_EMPOS_DATA
                            data['X'] = defaultInterp(0.0);
                            data['Y'] = defaultInterp(0.0);
                            data['Z'] = defaultInterp(0.0);
                        }
                        else if (type.includes('ANIMTEX')) { // FX_INFO_ANIMTEX_DATA
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['TEXID'] = defaultInterp(1.0);
                        }
                        else if (type.includes('GROUNDCOLLIDE')) { // FX_INFO_GROUNDCOLLIDE_DATA
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['BOUNCE'] = defaultInterp(0.8);
                            data['SPEEDMULT'] = defaultInterp(0.8);
                            data['BOUNCEERROR'] = defaultInterp(15.0);
                        }
                        else if (type.includes('TRAIL')) { // FX_INFO_TRAIL_DATA
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['TRAILTIME'] = defaultInterp(1.0);
                            data['SCREENSPACE'] = defaultInterp(0.0);
                        }
                        else if (type.includes('FLAT')) { // FX_INFO_FLAT_DATA (9 alignment vectors)
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['RX'] = defaultInterp(-1.0); data['RY'] = defaultInterp(0.0); data['RZ'] = defaultInterp(0.0);
                            data['UX'] = defaultInterp(0.0); data['UY'] = defaultInterp(1.0); data['UZ'] = defaultInterp(0.0);
                            data['AX'] = defaultInterp(0.0); data['AY'] = defaultInterp(0.0); data['AZ'] = defaultInterp(1.0);
                        }
                        else if (type.includes('JITTER')) { // FX_INFO_JITTER_DATA
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['JITTERFACTOR'] = defaultInterp(0.0);
                        }
                        else if (type.includes('ATTRACTPT')) { // FX_INFO_ATTRACTPT_DATA
                            data['TIMEMODEPRT'] = defaultFloat(1);
                            data['POSX'] = defaultInterp(0.0);
                            data['POSY'] = defaultInterp(0.0);
                            data['POSZ'] = defaultInterp(0.0);
                            data['FORCE'] = defaultInterp(0.0);
                        }
                        else if (type.includes('EMWEATHER')) { // FX_INFO_EMWEATHER_DATA
                            data['WINDMIN'] = defaultInterp(0.0);
                            data['WINDMAX'] = defaultInterp(1.0);
                            data['RAINMIN'] = defaultInterp(0.0);
                            data['RAINMAX'] = defaultInterp(1.0);
                        }
                        else {
                            data['UNINITIALIZED_PROPERTY'] = 0;
                        }

                        const info = { _id: uuid(), type: type, data };
                        found.item.infos.push(info);
                    }.bind(this)); // Bind context for forEach

                    // Select the first added item if possible, otherwise select the emitter
                    const newId = found.item.infos.length > 0 ? found.item.infos[found.item.infos.length - 1]._id : found.item._id;
                    this.select(newId);
                    this.save();
                }

                // Clear selection after closing modal
                this.selectedFxTypes = [];
                document.getElementById('confirm_add_fx_btn').disabled = true;
            },

            save: function () {
                if (document.getElementById('autosave-toggle').checked) {
                    localStorage.setItem('gta_fxp_autosave', JSON.stringify(this.data));
                }
            }
        };

        // --- Helper Functions (Moved to use global 'app' variable) ---

        function copyToClipboard() {
            if (!app.data) {
                customAlert("No project data to copy.", "error");
                return;
            }

            try {
                // Generate the full FXP text string
                const text = FXParser.stringify(app.data);

                // Use the modern Clipboard API
                navigator.clipboard.writeText(text).then(function () {
                    customAlert("Project data copied to clipboard!", "success");
                }, function (err) {
                    console.error('Async: Could not copy text: ', err);
                    customAlert("Failed to copy to clipboard.", "error");
                });
            } catch (err) {
                console.error('Sync: Could not copy text: ', err);
                customAlert("Error generating data.", "error");
            }
        }


        function saveToFile() {
            const text = FXParser.stringify(app.data);
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'effects.fxp'; a.click();
        }

        function saveJson() {
            const blob = new Blob([JSON.stringify(app.data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'project.json'; a.click();
        }

        function handleFileUpload(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                // We pass the filename to help decide logic if needed (e.g. extension check)
                app.importData(e.target.result, file.name);
            };
            reader.readAsText(file);

            // Clear input so onchange fires again for the same file
            input.value = '';
        }

        function handleTextureUpload(input) {
            // Define allowed extensions since HTML 'accept' is ignored in folder mode
            const allowedExtensions = ['.png', '.bmp', '.jpg', '.jpeg'];

            Array.from(input.files).forEach(function (file) {
                const lowerName = file.name.toLowerCase();

                // 1. FILTER: Check if file ends with valid extension
                const isValid = allowedExtensions.some(function (ext) {
                    return lowerName.endsWith(ext);
                });

                // Skip invalid files or hidden system files (starting with .)
                if (!isValid || lowerName.startsWith('.')) return;

                const url = URL.createObjectURL(file);

                // 2. NAMING: We use file.name (not full path). 
                // This ensures that 'folderA/grass.png' and 'folderB/grass.png' 
                // both result in the ID 'grass', satisfying your "Overwrite is intended" requirement.
                const name = file.name.split('.')[0].toLowerCase();

                new THREE.TextureLoader().load(
                    url,
                    function (tex) {
                        app.sim.textures[name] = tex;
                        customAlert(`Loaded texture: ${name}`, 'info');
                    },
                    undefined, // onProgress
                    function (err) {
                        console.warn(`Error loading ${name}:`, err);
                    }
                );
            });

            // Reset input so you can upload the same folder again if needed
            input.value = '';
        }

        function toggleAutosave(cb) { if (!cb.checked) localStorage.removeItem('gta_fxp_autosave'); }

        function showToast(msg, type) {
            const t = document.getElementById('toast-container');
            // FIX: Use setTimeout without arguments to prevent multiple toasts from clearing each other too fast
            // setTimeout(function () { t.innerHTML = ''; }, 2000); // Removed auto-clear
            t.innerHTML = `<div class="alert alert-${type}"><span>${msg}</span></div>`;
            setTimeout(function () {
                t.innerHTML = '';
            }, 3000); // Set a clear time of 3 seconds
        }

        // Initialize the application after the DOM is fully loaded and 'app' is defined.
        window.onload = function () {
            app.init();
        }
    </script>
</body>

</html>